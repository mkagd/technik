import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/router';
// USUNIÄ˜TO: GeocodingService i DistanceMatrixService importy
// PowÃ³d: CORS - uÅ¼ywamy API endpoints zamiast bezpoÅ›rednich wywoÅ‚aÅ„
import GoogleGeocoder from '../geocoding/simple/GoogleGeocoder.js';
import { suggestVisitDuration } from '../utils/repairTimeCalculator';
import { getApiCostMonitor } from '../utils/apiCostMonitor';
import { 
  AlertTriangle,
  Bot,
  Calendar,
  Car, 
  CheckCircle,
  ChevronLeft,
  ChevronRight,
  Clock, 
  DollarSign,
  Home,
  MapPin, 
  MessageCircle,
  RefreshCw,
  Settings,
  TrendingUp,
  Truck, 
  Users,
  Save
} from 'lucide-react';

const IntelligentWeekPlanner = () => {
  console.log('ğŸš€ğŸš€ğŸš€ IntelligentWeekPlanner COMPONENT RENDERING ğŸš€ğŸš€ğŸš€');
  
  const router = useRouter();
  
  // USUNIÄ˜TO: BezpoÅ›rednie inicjalizacje GeocodingService i DistanceMatrixService
  // PowÃ³d: CORS - frontend nie moÅ¼e bezpoÅ›rednio wywoÅ‚ywaÄ‡ Google API
  // RozwiÄ…zanie: Wszystkie wywoÅ‚ania przechodzÄ… przez API endpoints (/api/geocoding, /api/distance-matrix)

  // Stan przechowuje plany dla wszystkich serwisantÃ³w
  const [weeklyPlans, setWeeklyPlans] = useState({}); // { servicemanId: weeklyPlan }
  const [weeklyPlan, setWeeklyPlan] = useState(null); // Aktualnie wyÅ›wietlany plan
  const [isLoading, setIsLoading] = useState(false);
  const [selectedDay, setSelectedDay] = useState(null);
  
  // ğŸ†• Stan dla modalu ze szczegÃ³Å‚ami zlecenia
  const [selectedOrderModal, setSelectedOrderModal] = useState(null);
  const [showOrderDetailsModal, setShowOrderDetailsModal] = useState(false);
  
  //  Stan dla harmonogramÃ³w serwisantÃ³w (dostÄ™pnoÅ›Ä‡ godzinowa)
  const [servicemanSchedules, setServicemanSchedules] = useState({});
  const [dragOverInfo, setDragOverInfo] = useState(null); // PodglÄ…d pozycji podczas przeciÄ…gania na timeline
  
  // ï¿½ Stan dla linii aktualnej godziny
  const [currentTime, setCurrentTime] = useState(new Date());
  
  // Aktualizuj czas co minutÄ™
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 60000); // Co 60 sekund
    
    return () => clearInterval(timer);
  }, []);
  
  // ï¿½ğŸ’¾ Pomocnicze funkcje do localStorage
  const loadFromLocalStorage = (key, defaultValue) => {
    try {
      const saved = localStorage.getItem(`weekPlanner_${key}`);
      return saved !== null ? JSON.parse(saved) : defaultValue;
    } catch (error) {
      console.warn(`Failed to load ${key} from localStorage:`, error);
      return defaultValue;
    }
  };

  const saveToLocalStorage = (key, value) => {
    try {
      localStorage.setItem(`weekPlanner_${key}`, JSON.stringify(value));
    } catch (error) {
      console.warn(`Failed to save ${key} to localStorage:`, error);
    }
  };

  // â° Stan dla zakresu godzin timeline (z localStorage)
  const [timeRange, setTimeRange] = useState(() => loadFromLocalStorage('timeRange', { start: 6, end: 23 }));
  const [hideUnusedHours, setHideUnusedHours] = useState(() => loadFromLocalStorage('hideUnusedHours', false));
  
  // ğŸ·ï¸ Stan dla wyboru nagÅ‚Ã³wka karty zlecenia (z localStorage)
  const [cardHeaderField, setCardHeaderField] = useState(() => loadFromLocalStorage('cardHeaderField', 'clientName'));

  // Zapisuj zmiany do localStorage
  useEffect(() => {
    saveToLocalStorage('timeRange', timeRange);
  }, [timeRange]);

  useEffect(() => {
    saveToLocalStorage('hideUnusedHours', hideUnusedHours);
  }, [hideUnusedHours]);

  useEffect(() => {
    saveToLocalStorage('cardHeaderField', cardHeaderField);
  }, [cardHeaderField]);

  // ğŸ†• Handler dla klikniÄ™cia w zlecenie - otwiera modal ze szczegÃ³Å‚ami
  // ğŸ†• Funkcja pomocnicza do obsÅ‚ugi obu struktur danych (stara i nowa)
  const getWeeklyPlanData = useCallback((plan) => {
    if (!plan) return null;
    
    // Nowa struktura: { monday: {...}, tuesday: {...}, ..., unscheduledOrders: [...] }
    // Stara struktura: { weeklyPlan: { monday: {...}, ... }, unscheduledOrders: [...] }
    
    // SprawdÅº czy to nowa struktura (ma bezpoÅ›rednio dni tygodnia)
    if (plan.monday || plan.tuesday || plan.wednesday) {
      return plan; // Nowa struktura
    }
    
    // SprawdÅº czy to stara struktura (ma zagnieÅ¼dÅ¼ony weeklyPlan)
    if (plan.weeklyPlan) {
      return plan.weeklyPlan; // ZwrÃ³Ä‡ zagnieÅ¼dÅ¼ony plan
    }
    
    return null;
  }, []);

  const handleOrderClick = useCallback((order) => {
    console.log('ğŸ“‹ KlikniÄ™to zlecenie:', order);
    setSelectedOrderModal(order);
    setShowOrderDetailsModal(true);
  }, []);

  // Initialize Google Geocoder
  const geocoder = useRef(null);
  
  useEffect(() => {
    try {
      const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;
      if (apiKey) {
        geocoder.current = new GoogleGeocoder(apiKey);
        console.log('ğŸŒ Google Geocoder initialized successfully');
      } else {
        console.error('âŒ Google Maps API key not found');
      }
    } catch (error) {
      console.error('âŒ Failed to initialize Google Geocoder:', error);
    }
  }, []);

  const [optimizationPreferences, setOptimizationPreferences] = useState({
    priorityMode: 'balanced', // balanced, revenue, priority, time, vip
    maxDailyOrders: 12, // ZwiÄ™kszone do realistycznej liczby
    preferredStartTime: '08:00',
    startLocation: null, // BÄ™dzie ustawione dynamicznie
    workingHours: {
      start: '06:00', // NajwczeÅ›niejszy moÅ¼liwy wyjazd
      end: '22:00', // NajpÃ³Åºniejszy moÅ¼liwy powrÃ³t
      maxWorkingHours: 12 // Maksymalne godziny pracy dziennie
    }
  });

  // Stan dla lokalizacji startu
  const [startLocation, setStartLocation] = useState(null);

  // Dodajmy stan dla zaawansowanych opcji optymalizacji
  const [selectedOptimizationStrategy, setSelectedOptimizationStrategy] = useState('balanced');
  const [draggedOrder, setDraggedOrder] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [completedOrders, setCompletedOrders] = useState(new Set());
  const [currentWeekStart, setCurrentWeekStart] = useState(() => {
    // ZnajdÅº poniedziaÅ‚ek obecnego tygodnia
    const today = new Date();
    const dayOfWeek = today.getDay(); // 0 = niedziela, 1 = poniedziaÅ‚ek...
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; 
    const monday = new Date(today);
    monday.setDate(today.getDate() + mondayOffset);
    monday.setHours(0, 0, 0, 0);
    return monday;
  });

  // Stan dla systemu serwisantÃ³w
  const [availableServicemen, setAvailableServicemen] = useState([]);
  const [currentServiceman, setCurrentServiceman] = useState(null);
  const [showServicemanSelector, setShowServicemanSelector] = useState(false);
  
  const recalculateTimerRef = useRef({});

  // DostÄ™pne strategie optymalizacji
  const optimizationStrategies = {
    balanced: {
      name: 'âš–ï¸ Zbalansowana',
      description: 'Optymalne poÅ‚Ä…czenie priorytetu i przychodu',
      color: 'blue',
      focus: 'Uniwersalna strategia dla wiÄ™kszoÅ›ci przypadkÃ³w'
    },
    time: {
      name: 'â° NajkrÃ³tszy DzieÅ„',
      description: 'Minimalizacja caÅ‚kowitego czasu pracy',
      color: 'purple',
      focus: 'Maksymalna efektywnoÅ›Ä‡ czasowa'
    },
    revenue: {
      name: 'ğŸ’° Maksymalny PrzychÃ³d',
      description: 'Priorytet dla najdroÅ¼szych zleceÅ„',
      color: 'yellow',
      focus: 'Optymalizacja zysku dziennego'
    },
    priority: {
      name: 'ğŸš¨ Pilne Najpierw',
      description: 'ObsÅ‚uga pilnych zleceÅ„ w pierwszej kolejnoÅ›ci',
      color: 'red',
      focus: 'ZarzÄ…dzanie kryzysowe i awarie'
    },
    vip: {
      name: 'ğŸ‘‘ Klienci VIP',
      description: 'Preferencyjne traktowanie waÅ¼nych klientÃ³w',
      color: 'indigo',
      focus: 'ObsÅ‚uga strategicznych partnerÃ³w'
    },
    windows: {
      name: 'ğŸ• Okna Czasowe',
      description: 'Respektowanie preferencji klientÃ³w co do godzin',
      color: 'orange',
      focus: 'Dostosowanie do dostÄ™pnoÅ›ci klientÃ³w'
    }
  };

  // Funkcja do formatowania dnia z datÄ…
  const formatDayWithDate = (dayKey, weekStart) => {
    const dayNames = {
      monday: 'PoniedziaÅ‚ek',
      tuesday: 'Wtorek', 
      wednesday: 'Åšroda',
      thursday: 'Czwartek',
      friday: 'PiÄ…tek',
      saturday: 'Sobota',
      sunday: 'Niedziela'
    };
    
    const dayOffsets = {
      monday: 0,
      tuesday: 1,
      wednesday: 2,
      thursday: 3,
      friday: 4,
      saturday: 5,
      sunday: 6
    };
    
    const dayDate = new Date(weekStart);
    dayDate.setDate(weekStart.getDate() + dayOffsets[dayKey]);
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    dayDate.setHours(0, 0, 0, 0);
    
    const isToday = dayDate.getTime() === today.getTime();
    const isPast = dayDate.getTime() < today.getTime();
    
    const dateStr = dayDate.toLocaleDateString('pl-PL', { 
      day: '2-digit', 
      month: '2-digit' 
    });
    
    return {
      name: dayNames[dayKey],
      date: dateStr,
      fullDate: dayDate,
      isToday,
      isPast
    };
  };

  const dayNames = {
    monday: 'PoniedziaÅ‚ek',
    tuesday: 'Wtorek', 
    wednesday: 'Åšroda',
    thursday: 'Czwartek',
    friday: 'PiÄ…tek',
    saturday: 'Sobota',
    sunday: 'Niedziela'
  };

  const priorityColors = {
    high: 'bg-red-100 border-red-300 text-red-800',
    medium: 'bg-yellow-100 border-yellow-300 text-yellow-800',
    low: 'bg-green-100 border-green-300 text-green-800'
  };

  // ğŸ†• FUNKCJA: Åadowanie pracownikÃ³w z API
  const loadEmployeesFromAPI = useCallback(async () => {
    console.log('ğŸ‘·ğŸ‘·ğŸ‘· loadEmployeesFromAPI CALLED ğŸ‘·ğŸ‘·ğŸ‘·');
    console.log('ğŸ‘· Loading employees from /api/employees...');
    
    try {
      const response = await fetch('/api/employees');
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.employees && Array.isArray(result.employees)) {
        console.log(`âœ… Loaded ${result.employees.length} employees`);
        
        // Kolory dla pracownikÃ³w
        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#8B5CF6', '#EF4444', '#06B6D4', '#EC4899'];
        
        // PrzeksztaÅ‚Ä‡ pracownikÃ³w na format uÅ¼ywany przez planer
        const servicemen = result.employees
          .filter(emp => emp.isActive)
          .map((emp, index) => ({
            id: emp.id,
            name: emp.name,
            isActive: index === 0, // Pierwszy aktywny domyÅ›lnie
            color: colors[index % colors.length],
            email: emp.email,
            phone: emp.phone,
            specializations: emp.specializations || []
          }));
        
        setAvailableServicemen(servicemen);
        console.log('ğŸ‘· Available servicemen set:', servicemen.map(s => `${s.name} (${s.id})`));
        
        // Ustaw pierwszego pracownika jako domyÅ›lnego
        if (servicemen.length > 0 && !currentServiceman) {
          setCurrentServiceman(servicemen[0].id);
          console.log('âœ… Default serviceman set:', servicemen[0].name);
        }
        
        return { success: true, servicemen };
      } else {
        console.error('âŒ Invalid response format');
        return { success: false, error: 'Invalid response format' };
      }
    } catch (error) {
      console.error('âŒ Error loading employees:', error);
      showNotification('BÅ‚Ä…d Å‚adowania pracownikÃ³w', 'error');
      return { success: false, error: error.message };
    }
  }, [currentServiceman]);

  // ğŸ†• NOWA FUNKCJA: Åadowanie rzeczywistych danych z bazy (data/)
  const loadRealDataFromAPI = useCallback(async () => {
    console.log('ğŸ“¦ Loading real data from data/ folder...');
    console.log('ğŸ” Current serviceman:', currentServiceman);
    
    try {
      const response = await fetch(`/api/intelligent-planner/get-data?servicemanId=${currentServiceman || 'all'}`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.success) {
        console.log('âœ… Loaded real data:', result.data.metadata);
        console.log(`   ğŸ“¦ Orders: ${result.data.orders.length}`);
        console.log(`   ğŸ‘· Servicemen: ${result.data.servicemen.length}`);
        console.log(`   ğŸ“… Existing visits: ${result.data.visits.length}`);
        
        // Loguj przykÅ‚adowe zlecenia
        if (result.data.orders.length > 0) {
          console.log('   ğŸ“ PrzykÅ‚adowe zlecenia:');
          result.data.orders.slice(0, 3).forEach(order => {
            console.log(`      - ${order.id}: ${order.clientName} (status: ${order.status}, scheduledDate: ${order.scheduledDate})`);
          });
        }
        
        // Tutaj moÅ¼esz zapisaÄ‡ dane do lokalnego stanu jeÅ›li potrzebujesz
        // Na razie API intelligent-route-optimization sam je pobierze
        
        return {
          success: true,
          orders: result.data.orders,
          servicemen: result.data.servicemen,
          visits: result.data.visits
        };
      } else {
        console.error('âŒ Failed to load real data:', result.error);
        return { success: false, error: result.error };
      }
    } catch (error) {
      console.error('âŒ Error loading real data:', error);
      showNotification('BÅ‚Ä…d Å‚adowania danych z bazy', 'error');
      return { success: false, error: error.message };
    }
  }, [currentServiceman]);

  // ğŸ†• NOWA FUNKCJA: Zapisywanie planu do bazy danych
  const savePlanToDatabase = useCallback(async () => {
    const planData = getWeeklyPlanData(weeklyPlan);
    if (!weeklyPlan || !planData) {
      showNotification('âŒ Brak planu do zapisania', 'error');
      return;
    }
    
    console.log('ğŸ’¾ Saving plan to database...');
    setIsLoading(true);
    
    try {
      const currentServicemanData = availableServicemen.find(s => s.id === currentServiceman);
      
      const response = await fetch('/api/intelligent-planner/save-plan', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          servicemanId: currentServiceman,
          servicemanName: currentServicemanData?.name || 'Serwisant',
          weeklyPlan: planData,
          weekStart: currentWeekStart.toISOString()
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.success) {
        console.log('âœ… Plan saved successfully:', result.data);
        showNotification(
          `âœ… Plan zapisany! Utworzono ${result.data.createdVisitsCount} wizyt dla ${result.data.updatedOrdersCount} zleceÅ„`,
          'success'
        );
        
        // OdÅ›wieÅ¼ dane po zapisaniu
        setTimeout(() => {
          loadRealDataFromAPI();
        }, 1000);
        
        return true;
      } else {
        throw new Error(result.message || 'Unknown error');
      }
    } catch (error) {
      console.error('âŒ Error saving plan:', error);
      showNotification(`âŒ BÅ‚Ä…d zapisywania planu: ${error.message}`, 'error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [weeklyPlan, currentServiceman, availableServicemen, currentWeekStart, loadRealDataFromAPI]);

  // Helper function: Walidacja i normalizacja wspÃ³Å‚rzÄ™dnych
  const validateAndNormalizeCoordinates = useCallback((location) => {
    if (!location) return null;
    
    // JeÅ›li to obiekt z coordinates
    if (location.coordinates) {
      const { lat, lng } = location.coordinates;
      if (typeof lat === 'number' && typeof lng === 'number' && 
          !isNaN(lat) && !isNaN(lng) && 
          lat >= -90 && lat <= 90 && 
          lng >= -180 && lng <= 180) {
        return {
          lat,
          lng,
          address: location.address || `${lat}, ${lng}`
        };
      }
    }
    
    // JeÅ›li to bezpoÅ›rednio wspÃ³Å‚rzÄ™dne
    if (location.lat && location.lng) {
      const { lat, lng } = location;
      if (typeof lat === 'number' && typeof lng === 'number' && 
          !isNaN(lat) && !isNaN(lng) && 
          lat >= -90 && lat <= 90 && 
          lng >= -180 && lng <= 180) {
        return {
          lat,
          lng,
          address: location.address || `${lat}, ${lng}`
        };
      }
    }
    
    return null;
  }, []);

  // Åadowanie inteligentnego planu tygodniowego
  const loadIntelligentPlan = useCallback(async () => {
    console.log('ğŸš€ loadIntelligentPlan WYWOÅANE');
    
    // Prevent multiple concurrent executions
    if (loadIntelligentPlanMutexRef.current) {
      console.log('ğŸ”’ loadIntelligentPlan already in progress, skipping...');
      return;
    }
    
    loadIntelligentPlanMutexRef.current = true;
    console.log('ğŸ”’ Acquired mutex for loadIntelligentPlan');
    
    setIsLoading(true);
    try {
      // ğŸ†• KROK 1: Najpierw zaÅ‚aduj rzeczywiste dane z bazy
      console.log('ğŸ“Š STEP 1: Loading real data from database...');
      const realData = await loadRealDataFromAPI();
      
      // ğŸ“… KROK 1.5: ZaÅ‚aduj harmonogramy serwisantÃ³w (dostÄ™pnoÅ›Ä‡ godzinowa)
      if (currentServiceman) {
        try {
          // ğŸ“… ZaÅ‚aduj harmonogramy dla wszystkich 7 dni tygodnia
          const allSchedulesMap = {};
          const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
          
          for (let i = 0; i < 7; i++) {
            const dayDate = new Date(currentWeekStart);
            dayDate.setDate(dayDate.getDate() + i);
            const dateStr = dayDate.toISOString().split('T')[0];
            
            const scheduleResponse = await fetch(`/api/employee-calendar?action=get-all-schedules&date=${dateStr}`);
            const scheduleData = await scheduleResponse.json();
            
            if (scheduleData.success && scheduleData.schedules) {
              // Dla kaÅ¼dego pracownika, dodaj jego schedule tego dnia
              Object.keys(scheduleData.schedules).forEach(employeeId => {
                if (!allSchedulesMap[employeeId]) {
                  allSchedulesMap[employeeId] = {
                    workSlots: [],
                    breaks: []
                  };
                }
                
                const schedule = scheduleData.schedules[employeeId];
                const dayOfWeek = dayDate.getDay() || 7; // 0=Ndâ†’7, 1=Pon, ..., 6=Sob
                
                // Konwertuj timeSlots na workSlots (zakresy czasowe)
                if (schedule.timeSlots && schedule.timeSlots.length > 0) {
                  let currentSlot = null;
                  
                  schedule.timeSlots.forEach((slot) => {
                    if (slot.status === 'available' || slot.status === 'busy') {
                      if (!currentSlot) {
                        currentSlot = { startTime: slot.time, endTime: slot.time, dayOfWeek, type: 'work' };
                      }
                      currentSlot.endTime = slot.time;
                    } else if (slot.status === 'break') {
                      if (currentSlot) {
                        allSchedulesMap[employeeId].workSlots.push({...currentSlot});
                        currentSlot = null;
                      }
                    }
                  });
                  
                  if (currentSlot) {
                    allSchedulesMap[employeeId].workSlots.push({...currentSlot});
                  }
                }
              });
            }
          }
          
          setServicemanSchedules(allSchedulesMap);
          console.log('ğŸ“… ZaÅ‚adowano harmonogramy dla caÅ‚ego tygodnia:', Object.keys(allSchedulesMap).length, 'serwisantÃ³w');
          if (allSchedulesMap[currentServiceman]) {
            console.log(`  âœ… ${currentServiceman}: ${allSchedulesMap[currentServiceman].workSlots.length} workSlots`);
          }
        } catch (error) {
          console.warn('âš ï¸ Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ harmonogramÃ³w:', error);
        }
      }
      
      if (!realData.success) {
        showNotification('âš ï¸ Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ danych. UÅ¼ywam danych testowych.', 'warning');
        // Kontynuuj mimo to - API ma swoje fallbacki
      } else {
        console.log('âœ… Real data loaded successfully');
        showNotification(`ğŸ“¦ ZaÅ‚adowano ${realData.orders.length} zleceÅ„ z bazy danych`, 'success');
      }
      const preferences = { ...optimizationPreferences };
      
      // ğŸ†• UPROSZCZONE ÅADOWANIE: Pomijamy API optymalizacji (wymaga przypisanych zleceÅ„)
      // Zamiast tego uÅ¼ywamy juÅ¼ zaÅ‚adowanych danych z realData
      console.log('ğŸ“¦ Pomijam API optymalizacji - uÅ¼ywam juÅ¼ zaÅ‚adowanych danych');
      
      // SprawdÅº czy realData ma orders
      if (!realData || !realData.orders) {
        console.error('âŒ realData.orders jest undefined!', realData);
        showNotification('âš ï¸ Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ zleceÅ„', 'error');
        setWeeklyPlan({
          monday: { orders: [], stats: {} },
          tuesday: { orders: [], stats: {} },
          wednesday: { orders: [], stats: {} },
          thursday: { orders: [], stats: {} },
          friday: { orders: [], stats: {} },
          saturday: { orders: [], stats: {} },
          sunday: { orders: [], stats: {} },
          unscheduledOrders: [],
          recommendations: [],
          costAnalysis: {}
        });
        return;
      }
      
      // âœ… NOWA LOGIKA: Wszystkie zlecenia trafiajÄ… do "niezaplanowanych"
      // scheduledDate w bazie NIE MA ZNACZENIA - administrator przypisuje rÄ™cznie w plannerze
      console.log('ğŸ” ÅadujÄ™ zlecenia do plannera...');
      console.log(`   Wszystkich zleceÅ„ z API: ${realData.orders.length}`);
      
      // âœ… POPRAWKA: Pokazuj wszystkie zlecenia OPRÃ“CZ zakoÅ„czonych/anulowanych
      // DziÄ™ki temu zmiana statusu nie spowoduje znikniÄ™cia zlecenia z widoku
      const unscheduledOrders = realData.orders.filter(order => {
        // Wyklucz tylko zlecenia zakoÅ„czone, anulowane i te ktÃ³re nie stawili siÄ™
        const isExcludedStatus = order.status === 'completed' || 
                                 order.status === 'cancelled' || 
                                 order.status === 'no-show';
        
        // SprawdÅº czy zlecenie ma podstawowe dane (eliminuj uszkodzone rekordy)
        const hasValidData = order.clientName && (order.address || order.city);
        
        if (!hasValidData) {
          console.warn(`âš ï¸ Pomijam zlecenie ${order.id} - brak danych (clientName: ${order.clientName}, address: ${order.address})`);
        }
        
        // PokaÅ¼ zlecenie jeÅ›li NIE jest wykluczone i MA dane
        return !isExcludedStatus && hasValidData;
      });
      
      // Nie uÅ¼ywamy juÅ¼ scheduledOrders z bazy - wszystko idzie do unscheduled
      const scheduledOrders = [];
      
      console.log(`ğŸ“Š Zlecenia do zaplanowania: ${unscheduledOrders.length}`);
      console.log(`ğŸ“Š PominiÄ™to zleceÅ„: ${realData.orders.length - unscheduledOrders.length}`);
      
      // Loguj wszystkie statusy zleceÅ„
      const statusCounts = {};
      realData.orders.forEach(order => {
        const status = order.status || 'unknown';
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      });
      console.log(`ğŸ“Š Statusy zleceÅ„ (wszystkie):`, statusCounts);
      console.log(`   âœ… Zaakceptowane statusy: pending, new, contacted, scheduled, confirmed, in-progress, waiting-parts, ready`);
      console.log(`   âŒ Wykluczone statusy: completed, cancelled, no-show`);
      
      // Loguj pominiÄ™te zlecenia z powodu statusu
      const excludedOrders = realData.orders.filter(o => 
        o.status === 'completed' || o.status === 'cancelled' || o.status === 'no-show'
      );
      if (excludedOrders.length > 0) {
        console.log(`ğŸš« PominiÄ™to ${excludedOrders.length} zleceÅ„ (completed/cancelled/no-show):`, 
          excludedOrders.map(o => ({ id: o.id, status: o.status, client: o.clientName }))
        );
      }
      
      // Loguj zlecenia z brakujÄ…cymi danymi
      const ordersWithMissingData = realData.orders.filter(o => 
        !o.clientName || (!o.address && !o.city)
      );
      if (ordersWithMissingData.length > 0) {
        console.warn(`âš ï¸ Znaleziono ${ordersWithMissingData.length} zleceÅ„ z brakujÄ…cymi danymi:`, 
          ordersWithMissingData.map(o => ({ 
            id: o.id, 
            status: o.status,
            hasClient: !!o.clientName, 
            hasAddress: !!(o.address || o.city),
            data: o
          }))
        );
      }
      
      // PokaÅ¼ przykÅ‚adowe zlecenie
      if (unscheduledOrders.length > 0) {
        console.log(`  ğŸ“ PrzykÅ‚ad zlecenia do zaplanowania:`, {
          id: unscheduledOrders[0].id,
          client: unscheduledOrders[0].clientName,
          address: unscheduledOrders[0].address,
          status: unscheduledOrders[0].status,
          hasCoordinates: !!unscheduledOrders[0].coordinates
        });
      }
      
      // âœ… Ustaw weeklyPlan z PUSTYMI tablicami dla dni
      // Administrator rÄ™cznie przypisuje zlecenia z unscheduledOrders do konkretnych dni
      setWeeklyPlan({
        monday: { orders: [], stats: {} },
        tuesday: { orders: [], stats: {} },
        wednesday: { orders: [], stats: {} },
        thursday: { orders: [], stats: {} },
        friday: { orders: [], stats: {} },
        saturday: { orders: [], stats: {} },
        sunday: { orders: [], stats: {} },
        unscheduledOrders: unscheduledOrders,
        recommendations: [],
        costAnalysis: {}
      });
      
      showNotification(`âœ… ZaÅ‚adowano ${realData.orders.length} zleceÅ„`, 'success');
    } catch (error) {
      console.error('Network error:', error);
      showNotification(`BÅ‚Ä…d sieci: ${error.message}`, 'error');
    } finally {
      setIsLoading(false);
      // Release mutex lock
      loadIntelligentPlanMutexRef.current = false;
      console.log('ğŸ”“ Released mutex for loadIntelligentPlan');
    }
  }, [startLocation, optimizationPreferences, currentServiceman]); // âœ… Dodano currentServiceman!

  // Åadowanie pracownikÃ³w przy montowaniu komponentu
  useEffect(() => {
    console.log('ğŸ”¥ğŸ”¥ğŸ”¥ useEffect EMPLOYEES FIRED ğŸ”¥ğŸ”¥ğŸ”¥');
    
    // WywoÅ‚aj funkcjÄ™ bezpoÅ›rednio
    const loadEmployees = async () => {
      console.log('ğŸ‘·ğŸ‘·ğŸ‘· Loading employees INLINE ğŸ‘·ğŸ‘·ğŸ‘·');
      try {
        const response = await fetch('/api/employees');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const result = await response.json();
        console.log('âœ…âœ…âœ… GOT EMPLOYEES:', result.employees?.length);
        
        if (result.employees && Array.isArray(result.employees)) {
          const colors = ['#3B82F6', '#10B981', '#F59E0B', '#8B5CF6', '#EF4444', '#06B6D4', '#EC4899'];
          const servicemen = result.employees
            .filter(emp => emp.isActive)
            .map((emp, index) => ({
              id: emp.id,
              name: emp.name,
              isActive: index === 0,
              color: colors[index % colors.length],
              email: emp.email,
              phone: emp.phone,
              specializations: emp.specializations || [],
              address: emp.address || null,
              city: emp.city || null
            }));
          
          console.log('ğŸ‘· Setting availableServicemen:', servicemen.length);
          setAvailableServicemen(servicemen);
          
          if (servicemen.length > 0 && !currentServiceman) {
            console.log('âœ… Setting default serviceman:', servicemen[0].name);
            setCurrentServiceman(servicemen[0].id);
          }
        }
      } catch (error) {
        console.error('âŒâŒâŒ Error loading employees:', error);
      }
    };
    
    loadEmployees();
  }, []); // Tylko raz przy montowaniu

  // Ustaw lokalizacjÄ™ startu na podstawie wybranego pracownika
  useEffect(() => {
    if (!currentServiceman || !availableServicemen.length) return;

    const serviceman = availableServicemen.find(s => s.id === currentServiceman);
    if (!serviceman) return;

    // Ustaw domyÅ›lnÄ… lokalizacjÄ™ startu - KrakÃ³w centrum jako fallback
    if (!startLocation) {
      setStartLocation({
        address: serviceman.address || serviceman.city || 'KrakÃ³w, Polska',
        coordinates: {
          lat: 50.0647,
          lng: 19.9450
        }
      });
      console.log('ğŸ  Ustawiono domyÅ›lnÄ… lokalizacjÄ™ startu:', serviceman.address || 'KrakÃ³w, Polska');
    }
  }, [currentServiceman, availableServicemen, startLocation]);

  // Åadowanie danych przy pierwszym renderowaniu - tylko raz!
  useEffect(() => {
    // Tylko przy pierwszym mount
    if (!isInitialMountRef.current) return;
    
    // Poczekaj aÅ¼ lokalizacja bÄ™dzie gotowa, lub uÅ¼yj domyÅ›lnej po 2 sekundach
    initialLoadTimerRef.current = setTimeout(() => {
      if (isInitialMountRef.current) {
        console.log('â° Inicjalne Å‚adowanie planu - startLocation:', startLocation);
        loadIntelligentPlan();
        isInitialMountRef.current = false;
      }
    }, 2000);
    
    // JeÅ›li startLocation siÄ™ juÅ¼ pojawi wczeÅ›niej, zaÅ‚aduj od razu
    if (startLocation?.coordinates && isInitialMountRef.current) {
      clearTimeout(initialLoadTimerRef.current);
      console.log('ğŸ¯ RychÅ‚e Å‚adowanie - startLocation dostÄ™pne:', startLocation.coordinates);
      loadIntelligentPlan();
      isInitialMountRef.current = false;
    }
    
    return () => {
      if (initialLoadTimerRef.current) {
        clearTimeout(initialLoadTimerRef.current);
      }
      isInitialMountRef.current = false;
    };
  }, []); // TYLKO przy mount, bez dependencies na functions

  // PrzeÅ‚Ä…czanie planÃ³w gdy zmieni siÄ™ serwisant - TYLKO na zmianÄ™ serwisanta!
  useEffect(() => {
    // SprawdÅº czy rzeczywiÅ›cie zmieniÅ‚ siÄ™ serwisant
    if (prevServicemanRef.current === currentServiceman) {
      return;
    }
    
    // Zapisz aktualny plan przed przeÅ‚Ä…czeniem
    if (weeklyPlan && prevServicemanRef.current) {
      setWeeklyPlans(prev => ({
        ...prev,
        [prevServicemanRef.current]: weeklyPlan
      }));
    }

    // ZaÅ‚aduj plan dla nowego serwisanta
    if (weeklyPlans[currentServiceman]) {
      setWeeklyPlan(weeklyPlans[currentServiceman]);
    } else {
      // JeÅ›li nie ma planu dla tego serwisanta, zaÅ‚aduj nowy (bez dependencies loop)
      const loadTimer = setTimeout(() => {
        loadIntelligentPlan();
      }, 100);
      
      return () => clearTimeout(loadTimer);
    }
    
    // Zaktualizuj poprzedni serwisant
    prevServicemanRef.current = currentServiceman;
  }, [currentServiceman, weeklyPlans]); // Bezpieczne dependencies bez function refs

  // PrzeÅ‚aduj plan gdy zmieni siÄ™ lokalizacja startu - ZAWSZE reaguj na zmiany
  useEffect(() => {
    // SprawdÅº czy rzeczywiÅ›cie zmieniÅ‚ siÄ™ updatedAt
    if (!startLocation?.updatedAt || !startLocation?.coordinates) return;
    if (prevUpdatedAtRef.current === startLocation.updatedAt) return;
    
    console.log('ğŸ—ºï¸ PrzeÅ‚adowujÄ™ plan z nowÄ… lokalizacjÄ… startu:', startLocation.address);
    console.log('ğŸ“ Nowa lokalizacja wspÃ³Å‚rzÄ™dne:', startLocation.coordinates);
    
    // WyczyÅ›Ä‡ poprzedni debounce timer
    if (planReloadDebounceRef.current) {
      clearTimeout(planReloadDebounceRef.current);
    }
    
    // Debounce Å¼eby uniknÄ…Ä‡ wielokrotnych wywoÅ‚aÅ„
    planReloadDebounceRef.current = setTimeout(() => {
      console.log('ğŸ”„ WykonujÄ™ przeÅ‚adowanie planu po zmianie lokalizacji');
      loadIntelligentPlan();
      prevUpdatedAtRef.current = startLocation.updatedAt;
    }, 1000); // ZwiÄ™kszono do 1 sekundy dla stabilnoÅ›ci
    
    return () => {
      if (planReloadDebounceRef.current) {
        clearTimeout(planReloadDebounceRef.current);
      }
    };
  }, [startLocation?.updatedAt]); // Reaguj na updatedAt ale z zabezpieczeniami

  // Comprehensive cleanup on component unmount
  useEffect(() => {
    return () => {
      // Clear all notification timeouts
      if (notificationTimeouts.current) {
        notificationTimeouts.current.forEach((timeoutId) => {
          clearTimeout(timeoutId);
        });
        notificationTimeouts.current.clear();
      }
      
      // Clear all calculation debounce timers
      if (calculationDebounceRef.current) {
        calculationDebounceRef.current.forEach((timerId) => clearTimeout(timerId));
        calculationDebounceRef.current.clear();
      }
      
      // Clear location change debounce
      if (locationChangeDebounceRef.current) {
        clearTimeout(locationChangeDebounceRef.current);
      }
      
      // Clear plan reload debounce
      if (planReloadDebounceRef.current) {
        clearTimeout(planReloadDebounceRef.current);
      }
      
      // Clear initial load timer
      if (initialLoadTimerRef.current) {
        clearTimeout(initialLoadTimerRef.current);
      }
      
      // Reset mutex
      if (loadIntelligentPlanMutexRef.current) {
        loadIntelligentPlanMutexRef.current = false;
      }
      
      console.log('ğŸ§¹ Component cleanup completed - all timers cleared');
    };
  }, []);

  // Funkcja pomocnicza do pobierania tekstu nagÅ‚Ã³wka karty
  const getCardHeaderText = (order) => {
    switch (cardHeaderField) {
      case 'clientName':
        return order.clientName || 'Nieznany klient';
      case 'address':
        return order.address || 'Brak adresu';
      case 'deviceType':
        return order.deviceType || order.device?.type || 'Brak urzÄ…dzenia';
      case 'description':
        return order.description || 'Brak opisu';
      default:
        return order.clientName || 'Nieznany klient';
    }
  };

  // Renderowanie karty zlecenia z obsÅ‚ugÄ… drag & drop
  const renderOrderCard = (order, currentDay, orderIndex) => {
    // Przygotuj numery do wyÅ›wietlenia
    const orderNumber = order.orderNumber || order.visitId || `ORD-${order.id}`;
    const clientId = order.clientId || order.customerId || 'BRAK';
    const visitNumbers = order.visits && order.visits.length > 0 
      ? order.visits.map(v => v.visitId || v.id).join(', ')
      : 'Brak wizyt';
    
    console.log('ğŸ“‹ Rendering order card:', { 
      orderNumber, 
      clientId, 
      visitCount: order.visits?.length || 0,
      orderData: order 
    });
    
    const isCompleted = completedOrders.has(order.id);
    
    return (
      <div 
        key={order.id} 
        className={`p-3 rounded-lg border-2 mb-2 transition-all hover:shadow-md relative ${
          isCompleted 
            ? 'bg-green-50 border-green-300 opacity-75' 
            : priorityColors[order.priority]
        } ${isDragging && draggedOrder?.order.id === order.id ? 'opacity-50 scale-95' : ''}`}
        draggable={!isCompleted}
        onDragStart={(e) => handleDragStart(e, order, currentDay)}
        onDragEnd={handleDragEnd}
        title="PrzeciÄ…gnij aby przenieÅ›Ä‡ zlecenie do innego dnia"
        style={isCompleted ? { cursor: 'default' } : { cursor: 'move' }}
      >
        <div className="flex items-start justify-between">
          <div className="flex-1 min-w-0">
            {/* NagÅ‚Ã³wek z nazwÄ… klienta i statusem */}
            <div className="flex items-center gap-2 flex-wrap mb-1">
              <h4 
                className={`font-semibold text-sm truncate max-w-[200px] ${isCompleted ? 'line-through text-gray-500' : ''}`}
                title={getCardHeaderText(order)}
              >
                {getCardHeaderText(order)}
              </h4>
              <span className="text-xs text-gray-500 whitespace-nowrap hidden sm:inline">ğŸ“‹ PrzeciÄ…gnij</span>
              {isCompleted && <span className="text-xs text-green-600 whitespace-nowrap">âœ… Wykonane</span>}
            </div>
            
            {/* Numery: Zlecenie, Klient, Wizyty */}
            <div className="flex items-center gap-2 flex-wrap text-xs">
              <span className="text-blue-700 font-mono bg-blue-50 px-2 py-0.5 rounded" title="Numer zlecenia">
                ğŸ”¢ {orderNumber}
              </span>
              <span className="text-purple-700 font-mono bg-purple-50 px-2 py-0.5 rounded" title="ID klienta">
                ï¿½ {clientId}
              </span>
              {order.visits && order.visits.length > 0 && (
                <span className="text-green-700 font-mono bg-green-50 px-2 py-0.5 rounded" title={`Wizyty: ${visitNumbers}`}>
                  ğŸ“… {order.visits.length} wiz.
                </span>
              )}
            </div>
          <p className="text-xs opacity-75 mb-1 truncate" title={order.description}>{order.description}</p>
          <div className="flex items-center gap-3 text-xs flex-wrap">
            <span className="flex items-center gap-1 truncate max-w-[150px]" title={order.address}>
              <MapPin className="h-3 w-3 flex-shrink-0" />
              <span className="truncate">{order.address.split(',')[0]}</span>
            </span>
            <span className="flex items-center gap-1">
              <Clock className="h-3 w-3" />
              {order.estimatedDuration}min
            </span>
            <span className="flex items-center gap-1">
              <DollarSign className="h-3 w-3" />
              {order.serviceCost}zÅ‚
            </span>
          </div>
          {/* Rzeczywisty czas dojazdu */}
          <div className="mt-1">
            <TravelTimeInfo 
              order={order}
              previousLocation={orderIndex === 0 ? null : weeklyPlan?.weeklyPlan?.[currentDay]?.orders?.[orderIndex-1]?.coordinates}
              className="text-blue-600"
            />
          </div>
        </div>
        <div className="flex items-start gap-2">
          {/* Przycisk do oznaczania jako wykonane */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              toggleOrderCompletion(order.id);
            }}
            className={`px-2 py-1 rounded-full text-xs font-bold transition-colors ${
              isCompleted 
                ? 'bg-green-500 text-white hover:bg-green-600' 
                : 'bg-gray-200 text-gray-600 hover:bg-green-500 hover:text-white'
            }`}
            title={isCompleted ? "Oznacz jako niewykonane" : "Oznacz jako wykonane"}
          >
            {isCompleted ? 'âœ“' : 'â—‹'}
          </button>
          
          {/* Przycisk do przeniesienia z powrotem do nieprzypisanych */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              moveOrderToUnscheduled(order, currentDay);
            }}
            className="px-2 py-1 rounded text-xs font-medium bg-gray-200 text-gray-700 hover:bg-red-100 hover:text-red-700 transition-colors"
            title="PrzenieÅ› z powrotem do nieprzypisanych"
          >
            â†©ï¸
          </button>
          
          {/* Przycisk do zmiany technika */}
          {(() => {
            console.log('ğŸ” DEBUG Dropdown:', { 
              availableServicemen: availableServicemen.length, 
              currentServiceman,
              shouldShow: availableServicemen.length > 1 
            });
            return availableServicemen.length > 1;
          })() && (
            <select
              onClick={(e) => e.stopPropagation()}
              onChange={async (e) => {
                e.stopPropagation();
                const newTechnicianId = e.target.value;
                if (newTechnicianId && newTechnicianId !== currentServiceman) {
                  // Oblicz datÄ™ z currentDay (format: "2025-01-13")
                  const scheduledDate = order.scheduledDate || currentDay;
                  
                  console.log(`ğŸ”„ Zmiana technika: ${currentServiceman} â†’ ${newTechnicianId}`, {
                    orderId: order.id,
                    orderNumber: order.orderNumber,
                    scheduledDate: scheduledDate,
                    currentDay: currentDay
                  });
                  
                  try {
                    const response = await fetch(`/api/orders/${order.id}`, {
                      method: 'PATCH',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ 
                        assignedTo: newTechnicianId,
                        scheduledDate: scheduledDate // Zachowaj datÄ™ planowania!
                      })
                    });
                    
                    if (response.ok) {
                      const result = await response.json();
                      console.log('âœ… Zmiana technika zapisana:', result);
                      showNotification(`âœ… Zlecenie przypisane do innego technika`, 'success');
                      
                      // PrzeÅ‚aduj dane po zapisie
                      setTimeout(() => {
                        loadIntelligentPlan();
                      }, 500);
                    } else {
                      const error = await response.json();
                      console.error('âŒ BÅ‚Ä…d odpowiedzi API:', error);
                      showNotification(`âŒ BÅ‚Ä…d zmiany technika: ${error.message}`, 'error');
                    }
                  } catch (error) {
                    console.error('âŒ BÅ‚Ä…d zmiany technika:', error);
                    showNotification(`âŒ BÅ‚Ä…d zmiany technika`, 'error');
                  }
                }
              }}
              className="px-2 py-1 rounded text-xs font-medium bg-blue-100 text-blue-700 hover:bg-blue-200 transition-colors cursor-pointer"
              title="ZmieÅ„ technika"
              value={currentServiceman}
            >
              <option value="">ğŸ‘¤ ZmieÅ„...</option>
              {availableServicemen.map(tech => (
                <option key={tech.id} value={tech.id}>
                  {tech.name}
                </option>
              ))}
            </select>
          )}
          
          <span className={`px-2 py-1 rounded text-xs font-medium ${
            order.priority === 'high' ? 'bg-red-200 text-red-800' :
            order.priority === 'medium' ? 'bg-yellow-200 text-yellow-800' :
            'bg-green-200 text-green-800'
          }`}>
            {order.priority === 'high' ? 'Pilne' : 
             order.priority === 'medium' ? 'Åšrednie' : 'Niskie'}
          </span>
        </div>
      </div>
      
      {/* DostÄ™pnoÅ›Ä‡ klienta */}
      <div className="mt-2 pt-2 border-t border-gray-200">
        <div className="text-xs text-gray-600">
          <strong>DostÄ™pny:</strong>
          {order.preferredTimeSlots?.map((slot, idx) => (
            <span key={idx} className="ml-1">
              {slot.day === 'monday' ? 'Pon' :
               slot.day === 'tuesday' ? 'Wt' :
               slot.day === 'wednesday' ? 'Åšr' :
               slot.day === 'thursday' ? 'Czw' :
               slot.day === 'friday' ? 'Pt' :
               slot.day === 'saturday' ? 'Sob' :
               slot.day === 'sunday' ? 'Nd' : slot.day} 
              ({slot.start}-{slot.end})
              {idx < order.preferredTimeSlots.length - 1 ? ', ' : ''}
            </span>
          ))}
        </div>
        {order.unavailableDates?.length > 0 && (
          <div className="text-xs text-red-600 mt-1">
            <strong>NiedostÄ™pny:</strong> {order.unavailableDates.join(', ')}
          </div>
        )}
        {order.assignedTimeSlot && (
          <div className="text-xs text-blue-600 mt-1 font-medium">
            <strong>Przydzielone:</strong> {order.assignedTimeSlot.start}-{order.assignedTimeSlot.end}
            {order.assignedTimeSlot.autoAssigned && (
              <span className="ml-1 text-blue-500">âš¡ (auto)</span>
            )}
          </div>
        )}
      </div>
    </div>
    );
  };

  // ğŸ†• Pobierz zlecenia dla konkretnego dnia w aktualnym tygodniu
  const getOrdersForWeekDay = (day) => {
    // âœ… NOWA LOGIKA: Zlecenia sÄ… przechowywane bezpoÅ›rednio w weeklyPlan[day].orders
    // Administrator przypisuje je rÄ™cznie przez drag & drop z "niezaplanowanych"
    
    if (!weeklyPlan[day]) {
      console.warn(`âš ï¸ Brak planu dla dnia: ${day}`);
      return [];
    }
    
    const orders = weeklyPlan[day].orders || [];
    console.log(`ğŸ“… getOrdersForWeekDay(${day}) - zwracam ${orders.length} zleceÅ„ z weeklyPlan[${day}].orders`);
    
    return orders;
  };

  // ğŸ“… Pobierz harmonogram serwisanta dla danego dnia
  const getServicemanScheduleForDay = useCallback((day, servicemanId) => {
    if (!servicemanId) {
      return null;
    }
    
    if (!servicemanSchedules[servicemanId]) {
      return null;
    }
    
    // dayOfWeek: 1=Pon, 2=Wt, ..., 7=Nd
    const dayOfWeekMap = {
      monday: 1,
      tuesday: 2,
      wednesday: 3,
      thursday: 4,
      friday: 5,
      saturday: 6,
      sunday: 7
    };
    
    const dayOfWeek = dayOfWeekMap[day];
    const schedule = servicemanSchedules[servicemanId];
    
    // ZnajdÅº workSlots dla tego dnia
    const workSlots = (schedule.workSlots || []).filter(slot => slot.dayOfWeek === dayOfWeek);
    const breaks = (schedule.breaks || []).filter(br => br.dayOfWeek === dayOfWeek);
    
    console.log(`  âœ… Zwracam: ${workSlots.length} workSlots, ${breaks.length} breaks`);
    
    return { workSlots, breaks };
  }, [servicemanSchedules]);

  // Renderowanie harmonogramu dnia z rekomendacjami czasu
  const renderDaySchedule = (day, dayPlan) => {
    // ğŸ†• Zamiast uÅ¼ywaÄ‡ dayPlan.orders, pobierz rzeczywiste zlecenia z bazy filtrowane po dacie
    const orders = getOrdersForWeekDay(day);
    
    if (!orders || orders.length === 0) return null;
    
    // UsuniÄ™to kod rzeczywistych harmonogramÃ³w (Distance Matrix API)
    const realSchedule = null;
    
    // JeÅ›li mamy rzeczywisty harmonogram, uÅ¼yj go
    if (realSchedule && realSchedule.schedule) {
      const schedule = realSchedule.schedule;
      const departure = schedule.find(s => s.type === 'departure');
      const visits = schedule.filter(s => s.type === 'visit');
      const arrivalHome = schedule.find(s => s.type === 'arrival_home');
      
      return (
        <div className="mt-3 p-3 bg-blue-50 rounded-lg border border-blue-200">
          <h4 className="font-semibold text-sm mb-3 flex items-center gap-2 text-blue-800">
            <Clock className="h-4 w-4" />
            Harmonogram z Rzeczywistymi Czasami
            <span className="ml-2 px-2 py-1 bg-green-100 text-green-800 text-xs rounded-full">
              ğŸŒ Real-time
            </span>
          </h4>
          
          {/* Czas wyjazdu */}
          <div className="mb-3 p-2 bg-green-100 rounded border border-green-300">
            <div className="flex items-center justify-between">
              <span className="font-medium text-green-800">ğŸš— Wyjazd z domu:</span>
              <span className="font-bold text-green-800">
                {departure.time.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
              </span>
            </div>
            <div className="text-xs text-green-600 mt-1">
              ğŸ“ {startLocation.address}
            </div>
          </div>
          
          {/* Harmonogram wizyt */}
          <div className="space-y-2">
            {visits.map((visit, idx) => {
              const visitTypeLabels = {
                diagnosis: 'ğŸ” Diagnoza',
                repair: 'ğŸ”§ Naprawa',
                control: 'âœ… Kontrola',
                installation: 'ğŸ“¦ MontaÅ¼'
              };
              const visitTypeLabel = visitTypeLabels[visit.order.visitType] || 'ğŸ“‹ Wizyta';
              
              return (
                <div 
                  key={visit.order.visitId || visit.order.id} 
                  onClick={() => handleOrderClick(visit.order)}
                  className="p-2 bg-white rounded border border-gray-200 cursor-pointer hover:shadow-lg hover:border-blue-400 transition-all duration-200"
                >
                  <div className="flex items-center justify-between mb-1">
                    <div className="flex items-center gap-2">
                      <span className="font-medium text-sm hover:text-blue-600">
                        {visit.order.clientName}
                      </span>
                      {/* Typ wizyty */}
                      <span className="px-2 py-0.5 bg-blue-100 text-blue-800 text-xs rounded-full">
                        {visitTypeLabel}
                      </span>
                      {/* Numer wizyty w zleceniu */}
                      {visit.order.visitNumber && (
                        <span className="text-xs text-gray-500">
                          (wizyta {visit.order.visitNumber})
                        </span>
                      )}
                    </div>
                    <span className="text-xs text-gray-500">#{idx + 1}</span>
                  </div>
                  
                  {/* Numer zlecenia */}
                  {visit.order.orderNumber && (
                    <div className="text-xs text-gray-500 mb-2">
                      ğŸ“‹ Zlecenie: <span className="font-mono">{visit.order.orderNumber}</span>
                    </div>
                  )}
                  
                  <div className="grid grid-cols-2 gap-2 text-xs">
                    <div>
                      <span className="text-green-600">ğŸ“ Przyjazd:</span>
                      <span className="font-medium ml-1">
                        {visit.arrivalTime.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
                      </span>
                    </div>
                    <div>
                      <span className="text-red-600">ğŸ Wyjazd:</span>
                      <span className="font-medium ml-1">
                        {visit.departureTime.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
                      </span>
                    </div>
                    <div className="col-span-2 text-gray-600">
                    ğŸ”§ {visit.order.description || visit.order.issueDescription} ({visit.duration}min, {visit.order.serviceCost}zÅ‚)
                  </div>
                  <div className="col-span-2 text-gray-500 text-xs">
                    ğŸ“ {visit.order.address}
                  </div>
                  <div className="col-span-2">
                    <TravelTimeInfo 
                      order={visit.order}
                      previousLocation={idx === 0 ? null : visits[idx-1]?.order?.coordinates}
                      className="mt-1"
                    />
                  </div>
                </div>
                <div className="mt-2 text-xs text-blue-600 hover:text-blue-800">
                  ğŸ‘† Kliknij aby zobaczyÄ‡ szczegÃ³Å‚y
                </div>
              </div>
              );
            })}
          </div>
          
          {/* Czas powrotu */}
          <div className="mt-3 p-2 bg-purple-100 rounded border border-purple-300">
            <div className="flex items-center justify-between">
              <span className="font-medium text-purple-800">ğŸ  PowrÃ³t do domu:</span>
              <span className="font-bold text-purple-800">
                {arrivalHome.time.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
              </span>
            </div>
            <div className="text-xs text-purple-600 mt-1">
              â±ï¸ CaÅ‚kowity czas pracy: {(realSchedule.totalDuration / (1000 * 60 * 60)).toFixed(1)}h
            </div>
          </div>
        </div>
      );
    }
    
    // Fallback do starego systemu jeÅ›li jeszcze nie obliczono rzeczywistego harmonogramu
    const startTime = optimizationPreferences.preferredStartTime;
    const firstOrder = orders[0];
    
    // UÅ¼yj symulowanego czasu jako fallback
    const travelToFirst = 30; // Fallback 30 minut
    const firstVisitTime = new Date(`2025-10-01T${startTime}:00`);
    const departureTime = new Date(firstVisitTime.getTime() - travelToFirst * 60000);
    
    const minDepartureHour = parseTime(optimizationPreferences.workingHours.start);
    if (departureTime.getHours() * 60 + departureTime.getMinutes() < minDepartureHour) {
      departureTime.setHours(Math.floor(minDepartureHour / 60), minDepartureHour % 60, 0, 0);
      firstVisitTime.setTime(departureTime.getTime() + travelToFirst * 60000);
    }
    
    let currentTime = new Date(firstVisitTime);

    return (
      <div className="mt-3 p-3 bg-yellow-50 rounded-lg border border-yellow-200">
        <h4 className="font-semibold text-sm mb-3 flex items-center gap-2 text-yellow-800">
          <Clock className="h-4 w-4" />
          Harmonogram (obliczanie czasu rzeczywistego...)
          <span className="ml-2 px-2 py-1 bg-yellow-100 text-yellow-800 text-xs rounded-full">
            ğŸ“¡ Loading...
          </span>
        </h4>
        
        {/* Czas wyjazdu */}
        <div className="mb-3 p-2 bg-green-100 rounded border border-green-300">
          <div className="flex items-center justify-between">
            <span className="font-medium text-green-800">ğŸš— Wyjazd z domu:</span>
            <span className="font-bold text-green-800">
              {departureTime.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
            </span>
          </div>
          <div className="text-xs text-green-600 mt-1">
            ğŸ“ {startLocation.address}
          </div>
        </div>
        
        {/* Harmonogram wizyt */}
        <div className="space-y-2">
          {orders.map((order, idx) => {
            // JeÅ›li to nie pierwsza wizyta, dodaj symulowany czas dojazdu
            if (idx > 0) {
              currentTime = new Date(currentTime.getTime() + 20 * 60000); // 20 min fallback
            }
            
            const arrivalTime = new Date(currentTime);
            const orderDepartureTime = new Date(currentTime.getTime() + order.estimatedDuration * 60000);
            currentTime = orderDepartureTime;
            
            return (
              <div 
                key={order.id} 
                onClick={() => handleOrderClick(order)}
                className="p-2 bg-white rounded border border-gray-200 opacity-75 cursor-pointer hover:shadow-lg hover:border-blue-400 hover:opacity-100 transition-all duration-200"
              >
                <div className="flex items-center justify-between mb-1">
                  <span className="font-medium text-sm hover:text-blue-600">{order.clientName}</span>
                  <span className="text-xs text-gray-500">#{idx + 1}</span>
                </div>
                <div className="grid grid-cols-2 gap-2 text-xs">
                  <div>
                    <span className="text-green-600">ğŸ“ Przyjazd:</span>
                    <span className="font-medium ml-1">
                      {arrivalTime.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
                    </span>
                  </div>
                  <div>
                    <span className="text-red-600">ğŸ Wyjazd:</span>
                    <span className="font-medium ml-1">
                      {orderDepartureTime.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
                    </span>
                  </div>
                  <div className="col-span-2 text-gray-600">
                    ğŸ”§ {order.description} ({order.estimatedDuration}min, {order.serviceCost}zÅ‚)
                  </div>
                </div>
              </div>
            );
          })}
        </div>
        
        {/* Czas powrotu */}
        <div className="mt-3 p-2 bg-purple-100 rounded border border-purple-300">
          <div className="flex items-center justify-between">
            <span className="font-medium text-purple-800">ğŸ  PowrÃ³t do domu:</span>
            <span className="font-bold text-purple-800">
              {new Date(currentTime.getTime() + 30 * 60000).toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'})}
            </span>
          </div>
          <div className="text-xs text-purple-600 mt-1">
            â±ï¸ Szacowany czas pracy (dokÅ‚adne za chwilÄ™)
          </div>
        </div>
      </div>
    );
  };  

  // Individual calculation mutex per day to prevent race conditions
  const dayCalculationMutexRef = useRef(new Map());
  const loadIntelligentPlanMutexRef = useRef(false);
  const calculationDebounceRef = useRef(new Map()); // Debounce timers for calculations
  const apiCallQueueRef = useRef([]); // Queue for API calls to prevent rate limiting
  const lastApiCallRef = useRef(0); // Timestamp of last API call
  
  // Additional refs for preventing infinite loops and memory leaks
  const isInitialMountRef = useRef(true);
  const initialLoadTimerRef = useRef(null);
  const prevServicemanRef = useRef(currentServiceman);
  const planVersionRef = useRef(0);
  const prevLocationRef = useRef(null);
  const locationChangeDebounceRef = useRef(null);
  const prevUpdatedAtRef = useRef(null);
  const planReloadDebounceRef = useRef(null);

  // Rate limited API call function
  const makeRateLimitedApiCall = useCallback(async (url, options) => {
    const minInterval = 100; // Minimum 100ms between API calls
    const now = Date.now();
    const timeSinceLastCall = now - lastApiCallRef.current;
    
    if (timeSinceLastCall < minInterval) {
      await new Promise(resolve => setTimeout(resolve, minInterval - timeSinceLastCall));
    }
    
    lastApiCallRef.current = Date.now();
    return fetch(url, options);
  }, []);

  // Funkcja do zapisywania zlecenia do kalendarza (przypisywanie do konkretnego dnia)
  const saveOrderToSchedule = async (order, targetDay) => {
    try {
      console.log('ğŸ“Œ Zapisywanie zlecenia', order.id, 'na dzieÅ„', targetDay);
      
      const updatedPlan = { ...weeklyPlan };
      const unscheduledOrders = [...(updatedPlan.unscheduledOrders || [])];
      
      // UsuÅ„ z unscheduledOrders jeÅ›li tam jest
      updatedPlan.unscheduledOrders = unscheduledOrders.filter(o => o.id !== order.id);
      
      // âœ… NOWA STRUKTURA: Dodaj zlecenie bezpoÅ›rednio do weeklyPlan[day].orders
      // Najpierw sprawdÅº ktÃ³ry dzieÅ„ tygodnia odpowiada tej dacie
      const dayMap = {
        monday: updatedPlan.monday,
        tuesday: updatedPlan.tuesday,
        wednesday: updatedPlan.wednesday,
        thursday: updatedPlan.thursday,
        friday: updatedPlan.friday,
        saturday: updatedPlan.saturday,
        sunday: updatedPlan.sunday
      };
      
      // ZnajdÅº dzieÅ„ ktÃ³ry odpowiada targetDay (nazwa dnia, np. 'monday')
      const dayKey = Object.keys(dayMap).find(key => key === targetDay);
      
      if (dayKey && updatedPlan[dayKey]) {
        const updatedOrder = { ...order, scheduledDate: targetDay, assignedTo: currentServiceman };
        const currentOrders = [...(updatedPlan[dayKey].orders || [])];
        
        // UsuÅ„ jeÅ›li juÅ¼ istnieje i dodaj zaktualizowanÄ… wersjÄ™
        const filteredOrders = currentOrders.filter(o => o.id !== order.id);
        updatedPlan[dayKey].orders = [...filteredOrders, updatedOrder];
        
        console.log(`âœ… Dodano zlecenie ${order.id} do weeklyPlan.${dayKey}.orders (${updatedPlan[dayKey].orders.length} zleceÅ„)`);
      } else {
        console.error(`âŒ Nie znaleziono dnia: ${targetDay}`);
      }
      
      setWeeklyPlan(updatedPlan);
      
      // Zapisz do API
      const saveResponse = await fetch(`/api/orders/${order.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          scheduledDate: targetDay,
          assignedTo: currentServiceman
        })
      });
      
      if (saveResponse.ok) {
        console.log(`âœ… Zapisano zlecenie ${order.id} na dzieÅ„ ${targetDay}`);
        showNotification(`âœ… Zlecenie "${getCardHeaderText(order)}" zapisane na ${targetDay}`, 'success');
      } else {
        console.warn(`âš ï¸ Nie udaÅ‚o siÄ™ zapisaÄ‡ zmian:`, await saveResponse.text());
        loadIntelligentPlan();
        showNotification(`âŒ BÅ‚Ä…d zapisywania zmian`, 'error');
      }
    } catch (error) {
      console.error('âŒ BÅ‚Ä…d zapisywania zlecenia:', error);
      showNotification(`âŒ BÅ‚Ä…d: ${error.message}`, 'error');
      loadIntelligentPlan();
    }
  };

  // Funkcja do usuwania zlecenia z kalendarza (przywracanie do nieprzypisanych)
  const moveOrderToUnscheduled = async (order, sourceDay) => {
    try {
      console.log(`ğŸ“¤ Przenoszenie zlecenia ${order.id} z ${sourceDay} do nieprzypisanych`);
      
      const updatedPlan = { ...weeklyPlan };
      const unscheduledOrders = [...(updatedPlan.unscheduledOrders || [])];
      
      // âœ… NOWA STRUKTURA: UsuÅ„ z weeklyPlan[sourceDay].orders
      let orderToMove = null;
      
      if (sourceDay && updatedPlan[sourceDay]) {
        const dayOrders = [...(updatedPlan[sourceDay].orders || [])];
        orderToMove = dayOrders.find(o => o.id === order.id);
        
        if (orderToMove) {
          // UsuÅ„ z dnia
          updatedPlan[sourceDay].orders = dayOrders.filter(o => o.id !== order.id);
          console.log(`âœ… UsuniÄ™to zlecenie ${order.id} z weeklyPlan.${sourceDay}.orders`);
        }
      }
      
      // Dodaj do unscheduledOrders
      if (orderToMove) {
        updatedPlan.unscheduledOrders = [...unscheduledOrders, { ...orderToMove, scheduledDate: null, assignedTo: null }];
        console.log(`âœ… Dodano zlecenie ${order.id} do unscheduledOrders (${updatedPlan.unscheduledOrders.length} zleceÅ„)`);
        
        setWeeklyPlan(updatedPlan);
        
        // Zapisz do API - usuÅ„ scheduledDate
        const saveResponse = await fetch(`/api/orders/${order.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            scheduledDate: null,
            assignedTo: null
          })
        });
        
        if (saveResponse.ok) {
          console.log(`âœ… Przeniesiono zlecenie ${order.id} do nieprzypisanych`);
          showNotification(`âœ… Zlecenie "${getCardHeaderText(order)}" przeniesione do nieprzypisanych`, 'success');
        } else {
          console.warn(`âš ï¸ Nie udaÅ‚o siÄ™ zapisaÄ‡ zmian:`, await saveResponse.text());
          // Wycofaj zmiany
          loadIntelligentPlan();
          showNotification(`âŒ BÅ‚Ä…d zapisywania zmian`, 'error');
        }
      }
    } catch (error) {
      console.error('âŒ BÅ‚Ä…d przenoszenia zlecenia:', error);
      showNotification(`âŒ BÅ‚Ä…d: ${error.message}`, 'error');
      loadIntelligentPlan();
    }
  };

  // Funkcje drag & drop dla zleceÅ„
  const handleDragStart = (e, order, sourceDay) => {
    // Nie pozwalaj przeciÄ…gaÄ‡ wykonanych zleceÅ„
    if (completedOrders.has(order.id)) {
      e.preventDefault();
      console.log('âŒ Cannot drag completed order:', order.clientName);
      return;
    }
    
    console.log('ğŸ”µ Drag start:', order.clientName, 'from', sourceDay);
    setDraggedOrder({ order, sourceDay, sourceServiceman: currentServiceman });
    setIsDragging(true);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', ''); // Potrzebne dla niektÃ³rych przeglÄ…darek
    e.target.style.opacity = '0.5';
  };

  const handleDragEnd = (e) => {
    console.log('ğŸ”´ Drag end');
    e.target.style.opacity = '1';
    setIsDragging(false);
    setDraggedOrder(null);
  };

  const handleDragOver = (e, targetDay) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    // console.log('ğŸŸ¡ Drag over:', targetDay); // Zakomentowane Å¼eby nie spamowaÄ‡
  };

  const handleDrop = async (e, targetDay, insertIndex = null, targetServiceman = null) => {
    e.preventDefault();
    console.log('ğŸŸ¢ Drop:', targetDay, 'insertIndex:', insertIndex, 'targetServiceman:', targetServiceman);
    
    if (!draggedOrder) {
      console.log('âŒ No dragged order found');
      return;
    }

    const { order, sourceDay, sourceServiceman } = draggedOrder;
    const actualTargetServiceman = targetServiceman || currentServiceman;
    console.log('ğŸ“¦ Moving:', order.clientName, 'from', sourceDay, 'to', targetDay, 
                'from serviceman', sourceServiceman, 'to serviceman', actualTargetServiceman);
    
    // Przenoszenie miÄ™dzy serwisantami
    if (sourceServiceman !== actualTargetServiceman) {
      await handleServicemanTransfer(order, sourceDay, targetDay, sourceServiceman, actualTargetServiceman);
      return;
    }
    
    // JeÅ›li to ten sam dzieÅ„ i ten sam serwisant - zmiana kolejnoÅ›ci
    if (sourceDay === targetDay) {
      if (insertIndex !== null) {
        // TODO: Implementacja zmiany kolejnoÅ›ci dla nowej struktury
        // Obecnie nie modyfikujemy scheduledOrders - kolejnoÅ›Ä‡ bÄ™dzie sortowana przez getOrdersForWeekDay
        console.log('â„¹ï¸ Zmiana kolejnoÅ›ci w tym samym dniu - pomijam (wymaga osobnej implementacji)');
        
        showNotification(`âœ… Zmieniono kolejnoÅ›Ä‡ zlecenia "${order.clientName}" w ${getDayName(targetDay)}`);
      }
      return;
    }

    // Walidacja przeniesienia miÄ™dzy dniami
    const validation = validateOrderMove(order, sourceDay, targetDay);
    if (!validation.isValid) {
      showNotification(`âŒ Nie moÅ¼na przenieÅ›Ä‡ zlecenia: ${validation.reason}`, 'error');
      return;
    }

    // SprawdÅº ostrzeÅ¼enia
    if (validation.warnings && validation.warnings.length > 0) {
      validation.warnings.forEach(warning => {
        showNotification(`âš ï¸ ${warning}`, 'warning');
      });
    }

    // âœ… Aktualizuj plan tygodniowy - NOWA STRUKTURA
    const updatedPlan = { ...weeklyPlan };
    const unscheduledOrders = [...(updatedPlan.unscheduledOrders || [])];
    
    // Oblicz docelowÄ… datÄ™
    const targetDate = getDateForDay(targetDay);
    const scheduledDate = targetDate ? targetDate.toISOString().split('T')[0] : targetDay;
    
    const updatedOrder = { 
      ...order, 
      scheduledDate: scheduledDate,
      assignedTo: actualTargetServiceman || currentServiceman 
    };
    
    if (sourceDay === 'unscheduled') {
      // PrzenieÅ› z unscheduled do konkretnego dnia
      updatedPlan.unscheduledOrders = unscheduledOrders.filter(o => o.id !== order.id);
      console.log(`ğŸ“¤ UsuniÄ™to z unscheduled (pozostaÅ‚o: ${updatedPlan.unscheduledOrders.length})`);
      
      // Dodaj do weeklyPlan[targetDay].orders
      if (updatedPlan[targetDay]) {
        const dayOrders = [...(updatedPlan[targetDay].orders || [])];
        updatedPlan[targetDay].orders = [...dayOrders, updatedOrder];
        console.log(`ğŸ“¥ Dodano do weeklyPlan.${targetDay}.orders (teraz: ${updatedPlan[targetDay].orders.length})`);
      }
    } else {
      // Przenoszenie miÄ™dzy dniami
      // UsuÅ„ z dnia ÅºrÃ³dÅ‚owego
      if (updatedPlan[sourceDay]) {
        const sourceOrders = [...(updatedPlan[sourceDay].orders || [])];
        updatedPlan[sourceDay].orders = sourceOrders.filter(o => o.id !== order.id);
        console.log(`ğŸ“¤ UsuniÄ™to z ${sourceDay} (pozostaÅ‚o: ${updatedPlan[sourceDay].orders.length})`);
      }
      
      // Dodaj do dnia docelowego
      if (updatedPlan[targetDay]) {
        const targetOrders = [...(updatedPlan[targetDay].orders || [])];
        updatedPlan[targetDay].orders = [...targetOrders, updatedOrder];
        console.log(`ğŸ“¥ Dodano do ${targetDay} (teraz: ${updatedPlan[targetDay].orders.length})`);
      }
    }
    
    setWeeklyPlan(updatedPlan);
    
    // ğŸ†• Zapisz scheduledDate do bazy danych (w tle)
    try {
      console.log(`ğŸ’¾ ZapisujÄ™ scheduledDate dla zlecenia ${order.id}: ${scheduledDate}`);
      
      const saveResponse = await fetch(`/api/orders/${order.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          scheduledDate: scheduledDate,
          assignedTo: currentServiceman || order.assignedTo
        })
      });
      
      if (saveResponse.ok) {
        console.log(`âœ… Zapisano scheduledDate dla ${order.id}`);
        
        // ğŸ†• Zapisz caÅ‚y plan do bazy, Å¼eby utworzyÄ‡ wizytÄ™
        console.log('ğŸ’¾ Zapisywanie caÅ‚ego planu do stworzenia wizyty...');
        setTimeout(() => {
          savePlanToDatabase();
        }, 500);
      } else {
        console.warn(`âš ï¸ Nie udaÅ‚o siÄ™ zapisaÄ‡ scheduledDate:`, await saveResponse.text());
        // Wycofaj optymistycznÄ… aktualizacjÄ™ w przypadku bÅ‚Ä™du
        loadIntelligentPlan(); // PrzeÅ‚aduj dane z serwera
      }
    } catch (error) {
      console.error('âŒ BÅ‚Ä…d zapisywania scheduledDate:', error);
    }
    
    // PokaÅ¼ powiadomienie o sukcesie
    const sourceLabel = sourceDay === 'unscheduled' ? 'puli niezaplanowanych' : getDayName(sourceDay);
    showNotification(`âœ… Zlecenie "${order.clientName}" przeniesione z ${sourceLabel} na ${getDayName(targetDay)}`);
  };

  // Walidacja przeniesienia zlecenia
  const validateOrderMove = (order, sourceDay, targetDay) => {
    const planData = getWeeklyPlanData(weeklyPlan) || {};
    const targetDayOrders = planData[targetDay]?.orders || [];
    const warnings = [];
    
    // SprawdÅº limit zleceÅ„ dziennych
    if (targetDayOrders.length >= optimizationPreferences.maxDailyOrders) {
      return {
        isValid: false,
        reason: `DzieÅ„ ${getDayName(targetDay)} ma juÅ¼ maksymalnÄ… liczbÄ™ zleceÅ„ (${optimizationPreferences.maxDailyOrders})`
      };
    }
    
    // SprawdÅº dostÄ™pnoÅ›Ä‡ klienta w nowej dacie
    const targetDate = getDateForDay(targetDay);
    if (order.unavailableDates && order.unavailableDates.some(date => 
      new Date(date).toDateString() === targetDate.toDateString()
    )) {
      return {
        isValid: false,
        reason: `Klient ${order.clientName} nie jest dostÄ™pny w dniu ${targetDate.toLocaleDateString('pl-PL')}`
      };
    }
    
    // SprawdÅº godziny pracy - oblicz szacowany czas zakoÅ„czenia dnia
    const newOrdersList = [...targetDayOrders, order];
    
    // Dla walidacji uÅ¼ywamy szybkiej symulacji, dokÅ‚adne obliczenia bÄ™dÄ… pÃ³Åºniej
    let estimatedWorkingTime = 0;
    estimatedWorkingTime += newOrdersList.reduce((sum, ord) => sum + (ord.estimatedDuration || 60), 0);
    estimatedWorkingTime += (newOrdersList.length - 1) * 15; // PrzybliÅ¼one dojazdy miÄ™dzy
    estimatedWorkingTime += 60; // Z domu i z powrotem
    
    const workStart = parseTime(optimizationPreferences.workingHours.start);
    const workEnd = parseTime(optimizationPreferences.workingHours.end);
    const maxWorkingHours = optimizationPreferences.workingHours.maxWorkingHours;
    
    if (estimatedWorkingTime > maxWorkingHours * 60) { // Konwersja na minuty
      return {
        isValid: false,
        reason: `DzieÅ„ pracy przekroczyÅ‚by maksymalny czas (${maxWorkingHours}h). Szacowany czas: ${Math.round(estimatedWorkingTime/60)}h`
      };
    }
    
    // SprawdÅº czy dzieÅ„ zmieÅ›ci siÄ™ w godzinach pracy (6:00-22:00)
    const estimatedEndTime = workStart + estimatedWorkingTime;
    if (estimatedEndTime > workEnd) {
      const endHour = Math.floor(estimatedEndTime / 60);
      const endMinute = estimatedEndTime % 60;
      return {
        isValid: false,
        reason: `Praca zakoÅ„czyÅ‚aby siÄ™ o ${endHour.toString().padStart(2, '0')}:${endMinute.toString().padStart(2, '0')} (po dozwolonych godzinach pracy)`
      };
    }
    
    // SprawdÅº konflikty czasowe - bardziej elastyczne podejÅ›cie
    const timeConflicts = [];
    targetDayOrders.forEach(existingOrder => {
      if (order.preferredTimeSlots && existingOrder.preferredTimeSlots) {
        const conflicts = order.preferredTimeSlots.filter(orderSlot => 
          existingOrder.preferredTimeSlots.some(existingSlot => 
            doTimeSlotsOverlap(orderSlot, existingSlot)
          )
        );
        if (conflicts.length > 0) {
          timeConflicts.push({
            conflictingOrder: existingOrder,
            conflictingSlots: conflicts
          });
        }
      }
    });
    
    if (timeConflicts.length > 0) {
      // SprawdÅº czy moÅ¼na automatycznie rozwiÄ…zaÄ‡ konflikty
      const canResolveAutomatically = timeConflicts.every(conflict => 
        order.preferredTimeSlots && order.preferredTimeSlots.length > 1
      );
      
      if (canResolveAutomatically) {
        warnings.push(`Wykryto ${timeConflicts.length} konflikt(Ã³w) czasowych - zostanÄ… automatycznie rozwiÄ…zane`);
      } else {
        // Tylko blokuj jeÅ›li nie moÅ¼na automatycznie rozwiÄ…zaÄ‡
        const conflictDetails = timeConflicts.map(c => 
          `${c.conflictingOrder.clientName} (${c.conflictingSlots[0].start}-${c.conflictingSlots[0].end})`
        ).join(', ');
        warnings.push(`Konflikty czasowe z: ${conflictDetails} - sprawdÅº harmonogram po przeniesieniu`);
      }
    }
    
    // SprawdÅº ostrzeÅ¼enia (ale nie blokuj przeniesienia)
    
    // OstrzeÅ¼enie o przekroczeniu optymalnej liczby zleceÅ„
    if (targetDayOrders.length >= 10) {
      warnings.push(`DzieÅ„ ${getDayName(targetDay)} bÄ™dzie miaÅ‚ juÅ¼ ${targetDayOrders.length + 1} zleceÅ„ - moÅ¼e byÄ‡ przeciÄ…Å¼ony`);
    }
    
    // OstrzeÅ¼enie o priorytecie
    if (order.priority === 'high' && targetDay !== 'monday') {
      warnings.push(`Pilne zlecenie zostanie przesuniÄ™te na ${getDayName(targetDay)} - rozwaÅ¼ obsÅ‚ugÄ™ wczeÅ›niej`);
    }
    
    return { 
      isValid: true, 
      warnings: warnings.length > 0 ? warnings : null 
    };
  };

  // Funkcje pomocnicze do obsÅ‚ugi czasu i dat
  const parseTime = (timeString) => {
    // Konwertuje czas "HH:MM" na minuty od pÃ³Å‚nocy
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
  };

  const getDateForDay = (dayName) => {
    const dayIndex = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].indexOf(dayName);
    const date = new Date(currentWeekStart);
    date.setDate(currentWeekStart.getDate() + dayIndex);
    return date;
  };

  const calculateDayWorkingTime = async (orders, departureTime = null) => {
    // Szacuje caÅ‚kowity czas pracy dla listy zleceÅ„ (w minutach)
    if (!orders || orders.length === 0) return 0;
    
    let totalTime = 0;
    
    // Czas na kaÅ¼de zlecenie
    totalTime += orders.reduce((sum, order) => sum + (order.estimatedDuration || 60), 0);
    
    // Rzeczywisty czas dojazdÃ³w
    try {
      const travelTime = await calculateTotalTravelTime(orders, departureTime);
      totalTime += travelTime;
    } catch (error) {
      console.warn('âš ï¸ BÅ‚Ä…d obliczania czasu dojazdu, uÅ¼ywam fallback:', error);
      // Fallback do starych obliczeÅ„
      totalTime += (orders.length - 1) * 15; // MiÄ™dzy zleceniami
      totalTime += 60; // Z domu i z powrotem
    }
    
    return totalTime;
  };

  const doTimeSlotsOverlap = (slot1, slot2) => {
    // Sprawdza czy dwa okna czasowe siÄ™ pokrywajÄ…
    if (!slot1 || !slot2) return false;
    
    const start1 = parseTime(slot1.start);
    const end1 = parseTime(slot1.end);
    const start2 = parseTime(slot2.start);
    const end2 = parseTime(slot2.end);
    
    return (start1 < end2 && start2 < end1);
  };

  // ObsÅ‚uga przenoszenia zlecenia miÄ™dzy serwisantami
  const handleServicemanTransfer = async (order, sourceDay, targetDay, sourceServiceman, targetServiceman) => {
    // Pobierz plany obu serwisantÃ³w
    const sourcePlan = sourceServiceman === currentServiceman ? weeklyPlan : weeklyPlans[sourceServiceman];
    const targetPlan = targetServiceman === currentServiceman ? weeklyPlan : weeklyPlans[targetServiceman];

    if (!sourcePlan || !targetPlan) {
      showNotification('âŒ Nie moÅ¼na przenieÅ›Ä‡ zlecenia - brak dostÄ™pu do planu serwisanta', 'error');
      return;
    }

    // Walidacja przeniesienia dla docelowego serwisanta
    const validation = validateOrderMoveForServiceman(order, targetDay, targetPlan);
    if (!validation.isValid) {
      const targetServicemanName = availableServicemen.find(s => s.id === targetServiceman)?.name;
      showNotification(`âŒ Nie moÅ¼na przenieÅ›Ä‡ do ${targetServicemanName}: ${validation.reason}`, 'error');
      return;
    }

    // Wykonaj transfer
    const updatedSourcePlan = { ...sourcePlan };
    const updatedTargetPlan = { ...targetPlan };

    // UsuÅ„ z planu ÅºrÃ³dÅ‚owego
    updatedSourcePlan.weeklyPlan[sourceDay].orders = updatedSourcePlan.weeklyPlan[sourceDay].orders.filter(
      o => o.id !== order.id
    );

    // Dodaj do planu docelowego
    if (!updatedTargetPlan.weeklyPlan[targetDay].orders) {
      updatedTargetPlan.weeklyPlan[targetDay].orders = [];
    }
    updatedTargetPlan.weeklyPlan[targetDay].orders.push(order);

    // Przelicz statystyki
    await recalculateDayStats(updatedSourcePlan, sourceDay);
    await recalculateDayStats(updatedTargetPlan, targetDay);

    // Zaktualizuj stany
    if (sourceServiceman === currentServiceman) {
      setWeeklyPlan(updatedSourcePlan);
    } else {
      setWeeklyPlans(prev => ({ ...prev, [sourceServiceman]: updatedSourcePlan }));
    }

    if (targetServiceman === currentServiceman) {
      setWeeklyPlan(updatedTargetPlan);
    } else {
      setWeeklyPlans(prev => ({ ...prev, [targetServiceman]: updatedTargetPlan }));
    }

    // Powiadomienie
    const sourceServicemanName = availableServicemen.find(s => s.id === sourceServiceman)?.name;
    const targetServicemanName = availableServicemen.find(s => s.id === targetServiceman)?.name;
    showNotification(
      `âœ… Zlecenie "${order.clientName}" przeniesione z ${sourceServicemanName} (${getDayName(sourceDay)}) do ${targetServicemanName} (${getDayName(targetDay)})`,
      'success'
    );
  };

  // Walidacja przeniesienia dla konkretnego serwisanta
  const validateOrderMoveForServiceman = (order, targetDay, targetPlan) => {
    const targetDayOrders = targetPlan.weeklyPlan[targetDay]?.orders || [];
    
    // SprawdÅº limit zleceÅ„ dziennych
    if (targetDayOrders.length >= optimizationPreferences.maxDailyOrders) {
      return {
        isValid: false,
        reason: `DzieÅ„ ${getDayName(targetDay)} ma juÅ¼ maksymalnÄ… liczbÄ™ zleceÅ„ (${optimizationPreferences.maxDailyOrders})`
      };
    }

    // SprawdÅº godziny pracy - szybka walidacja
    const newOrdersList = [...targetDayOrders, order];
    let estimatedWorkingTime = 0;
    estimatedWorkingTime += newOrdersList.reduce((sum, ord) => sum + (ord.estimatedDuration || 60), 0);
    estimatedWorkingTime += (newOrdersList.length - 1) * 15; // PrzybliÅ¼one dojazdy
    estimatedWorkingTime += 60; // Z domu i z powrotem
    
    const maxWorkingHours = optimizationPreferences.workingHours.maxWorkingHours;
    
    if (estimatedWorkingTime > maxWorkingHours * 60) {
      return {
        isValid: false,
        reason: `DzieÅ„ pracy przekroczyÅ‚by maksymalny czas (${maxWorkingHours}h)`
      };
    }

    return { isValid: true };
  };

  // Automatyczne rozwiÄ…zywanie konfliktÃ³w czasowych
  const resolveTimeConflicts = (dayOrders) => {
    const resolvedOrders = [...dayOrders];
    const workStart = parseTime(optimizationPreferences.workingHours.start);
    const workEnd = parseTime(optimizationPreferences.workingHours.end);
    
    // Sortuj zlecenia wedÅ‚ug priorytetu: pilne -> Å›rednie -> niskie
    resolvedOrders.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
    
    // Przydziel automatycznie sloty czasowe
    let currentTime = workStart;
    const slotDuration = 90; // 1.5 godziny na zlecenie + dojazd
    
    resolvedOrders.forEach(order => {
      if (currentTime + slotDuration > workEnd) {
        // JeÅ›li nie mieÅ›ci siÄ™ w dniu pracy, przydziel na poczÄ…tek nastÄ™pnego dostÄ™pnego czasu
        currentTime = workStart;
      }
      
      // StwÃ³rz nowy slot czasowy
      const startHour = Math.floor(currentTime / 60);
      const startMinute = currentTime % 60;
      const endTime = currentTime + slotDuration;
      const endHour = Math.floor(endTime / 60);
      const endMinute = endTime % 60;
      
      order.assignedTimeSlot = {
        start: `${startHour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`,
        end: `${endHour.toString().padStart(2, '0')}:${endMinute.toString().padStart(2, '0')}`,
        autoAssigned: true
      };
      
      currentTime = endTime;
    });
    
    return resolvedOrders;
  };

  // Przelicz statystyki dnia po zmianie
  const recalculateDayStats = async (plan, day) => {
    // ğŸ”¥ OPTYMALIZACJA: Debounce 2s - nie przeliczaj przy kaÅ¼dym drag!
    if (recalculateTimerRef.current[day]) {
      clearTimeout(recalculateTimerRef.current[day]);
    }
    
    return new Promise((resolve) => {
      recalculateTimerRef.current[day] = setTimeout(async () => {
        console.log(`ğŸ’° Recalculating stats for ${day} (debounced)...`);
        
        // âœ… NOWA STRUKTURA: Pobierz zlecenia bezpoÅ›rednio z plan[day].orders
        let dayOrders = [];
        
        if (plan[day] && plan[day].orders) {
          dayOrders = [...plan[day].orders];
          console.log(`ğŸ“¦ Znaleziono ${dayOrders.length} zleceÅ„ w plan.${day}.orders`);
        } else {
          console.warn(`âš ï¸ Brak zleceÅ„ dla ${day}`);
          resolve();
          return;
        }
        
        // Automatycznie rozwiÄ…Å¼ konflikty czasowe
        if (dayOrders.length > 1) {
          dayOrders = resolveTimeConflicts(dayOrders);
          // Zaktualizuj orders w dniu
          plan[day].orders = dayOrders;
        }
        
        // ObsÅ‚uga obu struktur dla zapisania stats
        const isOldStructure = plan.weeklyPlan !== undefined;
        const dayData = isOldStructure ? plan.weeklyPlan[day] : plan[day];
        
        if (!dayData) {
          console.warn(`âš ï¸ recalculateDayStats: brak struktury dnia dla ${day}`);
          resolve();
          return;
        }
        
        if (dayOrders.length === 0) {
          dayData.stats = {
            totalRevenue: 0,
            totalTime: 0,
            efficiency: 0
          };
          resolve();
          return;
        }
        
        const totalRevenue = dayOrders.reduce((sum, order) => sum + (order.serviceCost || 0), 0);
        const totalWorkTime = dayOrders.reduce((sum, order) => sum + (order.estimatedDuration || 60), 0);
        
        // Oblicz rzeczywisty czas dojazdu
        let totalTravelTime = 0;
        try {
          totalTravelTime = await calculateTotalTravelTime(dayOrders);
        } catch (error) {
          console.warn('âš ï¸ BÅ‚Ä…d obliczania dojazdu w recalculateDayStats:', error);
          // Fallback
          totalTravelTime = dayOrders.length > 0 ? (dayOrders.length - 1) * 15 + 60 : 0;
        }
        
        const totalTime = totalTravelTime + totalWorkTime;
        
        // Zapisz statystyki do wÅ‚aÅ›ciwej struktury
        dayData.stats = {
          totalRevenue,
          totalTime,
          efficiency: totalRevenue / (totalTime / 60) // zÅ‚/godzinÄ™
        };
        
        resolve();
      }, 2000); // 2 sekundy debounce - czekaj aÅ¼ uÅ¼ytkownik skoÅ„czy przeciÄ…gaÄ‡
    });
  };

  // Pomocnicza funkcja do nazw dni
  const getDayName = (day) => {
    const dayNames = {
      monday: 'PoniedziaÅ‚ek',
      tuesday: 'Wtorek',
      wednesday: 'Åšroda',
      thursday: 'Czwartek',
      friday: 'PiÄ…tek',
      saturday: 'Sobota',
      sunday: 'Niedziela'
    };
    
    // JeÅ›li mamy dostÄ™p do currentWeekStart, pokazuj datÄ™
    if (currentWeekStart) {
      const dayInfo = formatDayWithDate(day, currentWeekStart);
      return `${dayNames[day] || day} (${dayInfo.date})`;
    }
    
    return dayNames[day] || day;
  };

  // System powiadomieÅ„
  const [notifications, setNotifications] = useState([]);
  const notificationTimeouts = useRef(new Map()); // Track timeout IDs to prevent memory leaks
  // Nowe funkcje UI - rozwijanie, sortowanie, filtrowanie (z localStorage)
  const [expandedDay, setExpandedDay] = useState(null); // RozwiniÄ™ty dzieÅ„ na peÅ‚ny ekran
  const [viewMode, setViewMode] = useState(() => loadFromLocalStorage('viewMode', 7)); // 1-7 kolumn (caÅ‚y tydzieÅ„)
  const [sortBy, setSortBy] = useState(() => loadFromLocalStorage('sortBy', 'default')); // default, priority, time, revenue, client
  const [filterBy, setFilterBy] = useState(() => loadFromLocalStorage('filterBy', 'all')); // all, high, medium, low, completed
  const [ordersPerPage, setOrdersPerPage] = useState(10); // Paginacja
  const [currentPage, setCurrentPage] = useState(1);

  // Reset paginacji gdy zmienia siÄ™ dzieÅ„, sortowanie lub filtrowanie
  useEffect(() => {
    setCurrentPage(1);
  }, [expandedDay, sortBy, filterBy]);

  // Zapisuj ustawienia UI do localStorage
  useEffect(() => {
    saveToLocalStorage('viewMode', viewMode);
  }, [viewMode]);

  useEffect(() => {
    saveToLocalStorage('sortBy', sortBy);
  }, [sortBy]);

  useEffect(() => {
    saveToLocalStorage('filterBy', filterBy);
  }, [filterBy]);

  // Funkcje sortowania i filtrowania zleceÅ„
  const sortOrders = (orders, sortType) => {
    if (!orders || orders.length === 0) return orders;
    
    const sorted = [...orders];
    switch (sortType) {
      case 'priority':
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return sorted.sort((a, b) => (priorityOrder[b.priority] || 1) - (priorityOrder[a.priority] || 1));
      case 'time':
        return sorted.sort((a, b) => (a.estimatedDuration || 60) - (b.estimatedDuration || 60));
      case 'revenue':
        return sorted.sort((a, b) => (b.serviceCost || 0) - (a.serviceCost || 0));
      case 'client':
        return sorted.sort((a, b) => (a.clientName || '').localeCompare(b.clientName || ''));
      default:
        return sorted;
    }
  };

  const filterOrders = (orders, filterType) => {
    if (!orders || orders.length === 0) return orders;
    
    switch (filterType) {
      case 'high':
        return orders.filter(order => order.priority === 'high');
      case 'medium':
        return orders.filter(order => order.priority === 'medium');
      case 'low':
        return orders.filter(order => order.priority === 'low');
      case 'completed':
        return orders.filter(order => completedOrders.has(order.id));
      case 'pending':
        return orders.filter(order => !completedOrders.has(order.id));
      default:
        return orders;
    }
  };

  const getProcessedOrders = (dayOrders) => {
    let processed = [...(dayOrders || [])];
    processed = filterOrders(processed, filterBy);
    processed = sortOrders(processed, sortBy);
    return processed;
  };

  // Funkcja do oznaczania zlecenia jako wykonane/niewykonane
  const toggleOrderCompletion = (orderId) => {
    setCompletedOrders(prev => {
      const newSet = new Set(prev);
      if (newSet.has(orderId)) {
        newSet.delete(orderId);
        showNotification('ğŸ“ Zlecenie oznaczone jako niewykonane', 'info');
      } else {
        newSet.add(orderId);
        showNotification('âœ… Zlecenie oznaczone jako wykonane!', 'success');
      }
      return newSet;
    });
  };

  const showNotification = (message, type = 'success') => {
    const notification = {
      id: Date.now(),
      message,
      type, // success, warning, error, info
      timestamp: new Date()
    };
    
    setNotifications(prev => [...prev, notification]);
    
    // Automatycznie usuÅ„ powiadomienie po 5 sekundach z proper cleanup
    const timeoutId = setTimeout(() => {
      setNotifications(prev => prev.filter(n => n.id !== notification.id));
      notificationTimeouts.current.delete(notification.id);
    }, 5000);
    
    // Store timeout ID for cleanup
    notificationTimeouts.current.set(notification.id, timeoutId);
  };

  const removeNotification = (id) => {
    // Clear timeout if exists
    const timeoutId = notificationTimeouts.current.get(id);
    if (timeoutId) {
      clearTimeout(timeoutId);
      notificationTimeouts.current.delete(id);
    }
    
    setNotifications(prev => prev.filter(n => n.id !== id));
  };

  // Optymalizacja pojedynczego dnia lub wszystkich dni
  const optimizeSingleDay = async (day) => {
    if (!weeklyPlan) return;

    setIsLoading(true);
    
    try {
      if (day === 'all') {
        // Optymalizuj wszystkie dni
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
        const updatedPlan = { ...weeklyPlan };
        
        for (const singleDay of days) {
          if (updatedPlan.weeklyPlan[singleDay]?.orders?.length > 0) {
            const dayOrders = [...updatedPlan.weeklyPlan[singleDay].orders];
            const optimizedOrders = applyOptimizationStrategy(dayOrders);
            updatedPlan.weeklyPlan[singleDay].orders = optimizedOrders;
            await recalculateDayStats(updatedPlan, singleDay);
          }
        }
        
        setWeeklyPlan(updatedPlan);
        showNotification(`âœ… Wszystkie dni zostaÅ‚y zoptymalizowane przy uÅ¼yciu strategii: ${optimizationStrategies[selectedOptimizationStrategy].name}`, 'success');
        return;
      }

      // Optymalizuj pojedynczy dzieÅ„
      const planData = getWeeklyPlanData(weeklyPlan);
      if (!planData || !planData[day] || !planData[day].orders) {
        return;
      }

      const dayOrders = [...planData[day].orders];
      let optimizedOrders = applyOptimizationStrategy(dayOrders);

      // Aktualizuj plan
      const updatedPlan = { ...weeklyPlan };
      if (updatedPlan.weeklyPlan) {
        // Stara struktura
        updatedPlan.weeklyPlan[day].orders = optimizedOrders;
      } else {
        // Nowa struktura
        updatedPlan[day].orders = optimizedOrders;
      }
      
      // Przelicz statystyki
      await recalculateDayStats(updatedPlan, day);
      
      setWeeklyPlan(updatedPlan);
      showNotification(`âœ… ${getDayName(day)} zostaÅ‚ zoptymalizowany przy uÅ¼yciu strategii: ${optimizationStrategies[selectedOptimizationStrategy].name}`, 'success');
      
    } catch (error) {
      console.error('BÅ‚Ä…d optymalizacji dnia:', error);
      showNotification(`âŒ Nie udaÅ‚o siÄ™ zoptymalizowaÄ‡ dnia ${getDayName(day)}`, 'error');
    } finally {
      setIsLoading(false);
    }
  };

  // Zastosuj wybranÄ… strategiÄ™ optymalizacji
  const applyOptimizationStrategy = (dayOrders) => {
    switch (selectedOptimizationStrategy) {
      case 'time':
        return optimizeByTime(dayOrders);
      case 'revenue':
        return optimizeByRevenue(dayOrders);
      case 'priority':
        return optimizeByPriority(dayOrders);
      case 'vip':
        return optimizeByVIP(dayOrders);
      case 'windows':
        return optimizeByTimeWindows(dayOrders);
      default:
        return optimizeBalanced(dayOrders);
    }
  };

  // Strategie optymalizacji pojedynczego dnia
  const optimizeByTime = (orders) => {
    // Sortuj po czasie realizacji (najkrÃ³tsze najpierw)
    return orders.sort((a, b) => (a.estimatedDuration || 60) - (b.estimatedDuration || 60));
  };

  const optimizeByRevenue = (orders) => {
    // Sortuj po przychodzie (najdroÅ¼sze najpierw)
    return orders.sort((a, b) => (b.serviceCost || 0) - (a.serviceCost || 0));
  };

  const optimizeByPriority = (orders) => {
    // Sortuj po priorytecie
    const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
    return orders.sort((a, b) => (priorityOrder[b.priority] || 1) - (priorityOrder[a.priority] || 1));
  };

  const optimizeByVIP = (orders) => {
    // Priorytet dla klientÃ³w VIP/premium
    return orders.sort((a, b) => {
      const isVipA = a.clientType === 'premium' || a.priority === 'high';
      const isVipB = b.clientType === 'premium' || b.priority === 'high';
      if (isVipA && !isVipB) return -1;
      if (!isVipA && isVipB) return 1;
      return (b.serviceCost || 0) - (a.serviceCost || 0);
    });
  };

  const optimizeByTimeWindows = (orders) => {
    // Sortuj po preferowanych oknach czasowych klientÃ³w
    return orders.sort((a, b) => {
      const timeA = a.preferredTimeSlots?.[0]?.start || '08:00';
      const timeB = b.preferredTimeSlots?.[0]?.start || '08:00';
      return timeA.localeCompare(timeB);
    });
  };

  const optimizeBalanced = (orders) => {
    // Strategia zbalansowana - kombinacja wszystkich czynnikÃ³w (priorytet + przychÃ³d)
    return orders.sort((a, b) => {
      const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
      
      const scoreA = (priorityOrder[a.priority] || 1) * 0.4 + 
                    ((a.serviceCost || 0) / 1000) * 0.6;
      const scoreB = (priorityOrder[b.priority] || 1) * 0.4 + 
                    ((b.serviceCost || 0) / 1000) * 0.6;
      return scoreB - scoreA;
    });
  };

  // Renderowanie szczegÃ³Å‚owych statystyk dnia z zarobkami
  const renderDayStats = (day, stats) => {
    if (!stats) return null;
    
    const planData = getWeeklyPlanData(weeklyPlan) || {};
    const dayOrders = planData[day]?.orders || [];
    
    return (
      <div className="mt-3 p-3 bg-gray-50 rounded-lg">
        <h4 className="font-semibold text-sm mb-2 flex items-center gap-2">
          <TrendingUp className="h-4 w-4" />
          SzczegÃ³Å‚owe statystyki dnia
        </h4>
        
        {/* GÅ‚Ã³wne statystyki */}
        <div className="grid grid-cols-2 gap-3 text-xs mb-3">
          <div>
            <span className="font-medium">Zlecenia:</span> {stats.totalOrders}
          </div>
          <div className="font-semibold text-green-600">
            <span className="font-medium">ÅÄ…cznie zarobiÄ™:</span> {stats.totalRevenue}zÅ‚
          </div>
          <div>
            <span className="font-medium">Czas serwisu:</span> {Math.round(stats.totalServiceTime/60)}h
          </div>
          <div>
            <span className="font-medium">Czas dojazdu:</span> {Math.round(stats.totalTravelTime/60)}h
          </div>
          <div className="col-span-2">
            <span className="font-medium">Regiony:</span> {stats.regions?.join(', ')}
          </div>
          <div className="col-span-2">
            <span className="font-medium">EfektywnoÅ›Ä‡:</span> 
            <span className={`ml-1 ${stats.efficiency > 15 ? 'text-green-600' : 
                             stats.efficiency > 10 ? 'text-yellow-600' : 'text-red-600'}`}>
              {stats.efficiency?.toFixed(1)}zÅ‚/min
            </span>
          </div>
        </div>

        {/* SzczegÃ³Å‚owy breakdown zarobkÃ³w */}
        {dayOrders.length > 0 && (
          <div className="border-t border-gray-200 pt-3">
            <h5 className="font-medium text-xs mb-2 text-gray-700">ğŸ’° Detale zarobkÃ³w:</h5>
            <div className="space-y-1">
              {dayOrders.map((order, index) => (
                <div key={order.id} className="flex justify-between items-center text-xs">
                  <span className="text-gray-600">
                    {index + 1}. {order.clientName}
                  </span>
                  <span className="font-medium text-green-600">{order.serviceCost}zÅ‚</span>
                </div>
              ))}
              <div className="border-t border-gray-300 pt-1 flex justify-between items-center text-xs font-bold">
                <span>Razem dziennie:</span>
                <span className="text-green-600 text-sm">{dayOrders.reduce((sum, order) => sum + order.serviceCost, 0)}zÅ‚</span>
              </div>
              <div className="text-xs text-gray-500 mt-1">
                Åšrednio na zlecenie: {dayOrders.length > 0 ? Math.round(dayOrders.reduce((sum, order) => sum + order.serviceCost, 0) / dayOrders.length) : 0}zÅ‚
              </div>
            </div>
          </div>
        )}
      </div>
    );
  };

  // Komponent do wyÅ›wietlania informacji o czasie dojazdu
  const TravelTimeInfo = ({ order, previousLocation = null, className = "" }) => {
    const fromLocation = previousLocation || startLocation?.coordinates;
    if (!fromLocation || !order.coordinates) return null;

    const key = `${fromLocation.lat},${fromLocation.lng}->${order.coordinates.lat},${order.coordinates.lng}`;
    const travelInfo = realTravelTimes.get(key);
    const isLoading = loadingTravelTimes.has(key);

    if (isLoading) {
      return (
        <div className={`flex items-center gap-1 text-xs text-gray-500 ${className}`}>
          <Clock className="h-3 w-3 animate-pulse" />
          <span>Obliczam...</span>
        </div>
      );
    }

    if (!travelInfo) {
      return (
        <div className={`flex items-center gap-1 text-xs text-gray-400 ${className}`}>
          <Clock className="h-3 w-3" />
          <span>~15min</span>
        </div>
      );
    }

    return (
      <div className={`flex items-center gap-1 text-xs ${className}`}>
        <Car className="h-3 w-3" />
        <span className={travelInfo.hasTraffic ? 'text-orange-600' : 'text-blue-600'}>
          {travelInfo.distance}km, {travelInfo.duration}min
        </span>
        {travelInfo.trafficDelay > 0 && (
          <span className="text-red-500" title={`OpÃ³Åºnienie z powodu ruchu: +${travelInfo.trafficDelay}min`}>
            (+{travelInfo.trafficDelay})
          </span>
        )}
      </div>
    );
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <RefreshCw className="h-8 w-8 animate-spin mx-auto mb-4 text-blue-600" />
          <p className="text-lg font-semibold">OptymalizujÄ™ trasy tygodniowe...</p>
          <p className="text-sm text-gray-600 mt-2">AnalizujÄ™ dostÄ™pnoÅ›Ä‡ klientÃ³w i grupujÄ™ geograficznie</p>
        </div>
      </div>
    );
  }

  if (!weeklyPlan) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center max-w-md">
          <AlertTriangle className="h-12 w-12 mx-auto mb-4 text-yellow-600" />
          <h2 className="text-xl font-bold mb-2">Brak danych do optymalizacji</h2>
          <p className="text-gray-600 mb-4">Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ planu tygodniowego.</p>
          <button 
            onClick={loadIntelligentPlan}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            SprÃ³buj ponownie
          </button>
        </div>
      </div>
    );
  }

  // ğŸ†• Komponent modalu ze szczegÃ³Å‚ami zlecenia
  const OrderDetailsModal = () => {
    if (!showOrderDetailsModal || !selectedOrderModal) return null;

    const order = selectedOrderModal;

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div className="bg-white rounded-lg shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
          {/* Header */}
          <div className="sticky top-0 bg-gradient-to-r from-blue-600 to-purple-600 text-white p-6 rounded-t-lg">
            <div className="flex items-start justify-between">
              <div>
                <h3 className="text-2xl font-bold mb-2">
                  {order.clientName || 'Nieznany klient'}
                </h3>
                <p className="text-blue-100 text-sm">
                  ID: {order.id}
                </p>
              </div>
              <button
                onClick={() => setShowOrderDetailsModal(false)}
                className="text-white hover:bg-white hover:bg-opacity-20 rounded-full p-2 transition-colors"
              >
                âœ•
              </button>
            </div>
          </div>

          {/* Body */}
          <div className="p-6 space-y-6">
            {/* Podstawowe informacje */}
            <div className="grid grid-cols-2 gap-4">
              <div className="col-span-2 md:col-span-1">
                <h4 className="text-sm font-semibold text-gray-600 mb-2 flex items-center gap-2">
                  <MapPin className="h-4 w-4" />
                  Adres
                </h4>
                <p className="text-gray-800">{order.address || 'Brak adresu'}</p>
                {order.coordinates && (
                  <p className="text-xs text-gray-500 mt-1">
                    ğŸ“ {order.coordinates.lat?.toFixed(4)}, {order.coordinates.lng?.toFixed(4)}
                  </p>
                )}
              </div>

              <div className="col-span-2 md:col-span-1">
                <h4 className="text-sm font-semibold text-gray-600 mb-2 flex items-center gap-2">
                  <Users className="h-4 w-4" />
                  Kontakt
                </h4>
                <p className="text-gray-800">{order.phone || 'Brak telefonu'}</p>
              </div>
            </div>

            {/* Opis problemu */}
            <div>
              <h4 className="text-sm font-semibold text-gray-600 mb-2">
                ğŸ”§ Opis problemu
              </h4>
              <p className="text-gray-800 bg-gray-50 p-3 rounded-lg">
                {order.description || order.issueDescription || 'Brak opisu'}
              </p>
            </div>

            {/* SzczegÃ³Å‚y serwisowe */}
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
              <div className="bg-blue-50 p-4 rounded-lg">
                <p className="text-sm text-gray-600 mb-1">Priorytet</p>
                <p className={`font-bold text-lg ${
                  order.priority === 'high' ? 'text-red-600' :
                  order.priority === 'medium' ? 'text-yellow-600' :
                  'text-green-600'
                }`}>
                  {order.priority === 'high' ? 'ğŸ”´ Wysoki' :
                   order.priority === 'medium' ? 'ğŸŸ¡ Åšredni' :
                   'ğŸŸ¢ Niski'}
                </p>
              </div>

              <div className="bg-green-50 p-4 rounded-lg">
                <p className="text-sm text-gray-600 mb-1">Szacowany czas</p>
                <p className="font-bold text-lg text-gray-800">
                  â±ï¸ {order.estimatedDuration || 60} min
                </p>
              </div>

              <div className="bg-purple-50 p-4 rounded-lg">
                <p className="text-sm text-gray-600 mb-1">Koszt usÅ‚ugi</p>
                <p className="font-bold text-lg text-gray-800">
                  ğŸ’° {order.serviceCost || 0} zÅ‚
                </p>
              </div>
            </div>

            {/* Preferowane terminy */}
            {order.preferredTimeSlots && order.preferredTimeSlots.length > 0 && (
              <div>
                <h4 className="text-sm font-semibold text-gray-600 mb-3">
                  ğŸ“… DostÄ™pnoÅ›Ä‡ klienta
                </h4>
                <div className="space-y-2">
                  {order.preferredTimeSlots.map((slot, idx) => (
                    <div key={idx} className="bg-blue-50 p-3 rounded-lg flex items-center justify-between">
                      <span className="font-medium capitalize">
                        {slot.day === 'monday' ? 'PoniedziaÅ‚ek' :
                         slot.day === 'tuesday' ? 'Wtorek' :
                         slot.day === 'wednesday' ? 'Åšroda' :
                         slot.day === 'thursday' ? 'Czwartek' :
                         slot.day === 'friday' ? 'PiÄ…tek' :
                         slot.day === 'saturday' ? 'Sobota' :
                         'Niedziela'}
                      </span>
                      <span className="text-sm text-gray-600">
                        {slot.start} - {slot.end}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* NiedostÄ™pne daty */}
            {order.unavailableDates && order.unavailableDates.length > 0 && (
              <div>
                <h4 className="text-sm font-semibold text-gray-600 mb-2">
                  âŒ NiedostÄ™pne daty
                </h4>
                <div className="flex flex-wrap gap-2">
                  {order.unavailableDates.map((date, idx) => (
                    <span key={idx} className="px-3 py-1 bg-red-100 text-red-800 rounded-full text-sm">
                      {date}
                    </span>
                  ))}
                </div>
              </div>
            )}

            {/* Czy moÅ¼na przeÅ‚oÅ¼yÄ‡ */}
            <div className="flex items-center gap-3 bg-gray-50 p-4 rounded-lg">
              <div className={`w-3 h-3 rounded-full ${order.canReschedule ? 'bg-green-500' : 'bg-red-500'}`} />
              <span className="text-gray-700">
                {order.canReschedule ? 
                  'âœ… Zlecenie moÅ¼na przeÅ‚oÅ¼yÄ‡ na inny termin' : 
                  'ğŸ”’ Zlecenie ma sztywny termin'}
              </span>
            </div>

            {/* ğŸ†• SEKCJA WIZYT - Timeline wizyt w zleceniu */}
            {order.orderNumber && (
              <div className="border-t-2 border-blue-200 pt-6">
                <h4 className="text-lg font-bold text-gray-800 mb-4 flex items-center gap-2">
                  ğŸ“‹ Historia wizyt w zleceniu {order.orderNumber}
                </h4>
                
                {/* Informacja o aktualnej wizycie */}
                {order.visitNumber && (
                  <div className="mb-4 p-3 bg-blue-100 border-l-4 border-blue-500 rounded">
                    <p className="text-sm text-blue-800">
                      <strong>Obecnie wyÅ›wietlasz:</strong> Wizyta #{order.visitNumber} 
                      {order.visitType && ` - ${
                        order.visitType === 'diagnosis' ? 'ğŸ” Diagnoza' :
                        order.visitType === 'repair' ? 'ğŸ”§ Naprawa' :
                        order.visitType === 'control' ? 'âœ… Kontrola' :
                        order.visitType === 'installation' ? 'ğŸ“¦ MontaÅ¼' :
                        order.visitType
                      }`}
                    </p>
                  </div>
                )}

                {/* PrzykÅ‚adowa timeline - w prawdziwej implementacji pobierzesz to z API */}
                <div className="space-y-3">
                  <div className="text-sm text-gray-600 italic mb-3">
                    ğŸ’¡ PoniÅ¼ej zobaczysz wszystkie wizyty powiÄ…zane z tym zleceniem
                  </div>
                  
                  {/* Wizyta obecna (przykÅ‚ad) */}
                  <div className={`p-4 rounded-lg border-2 ${
                    order.visitNumber === 1 ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'
                  }`}>
                    <div className="flex items-center justify-between mb-2">
                      <span className="font-bold text-gray-800">
                        {order.visitType === 'diagnosis' ? 'ğŸ” Diagnoza' : 
                         order.visitType === 'repair' ? 'ğŸ”§ Naprawa' :
                         order.visitType === 'control' ? 'âœ… Kontrola' :
                         'ğŸ“‹ Wizyta'} #{order.visitNumber || 1}
                      </span>
                      <span className={`px-3 py-1 rounded-full text-xs font-semibold ${
                        order.status === 'completed' ? 'bg-green-100 text-green-800' :
                        order.status === 'scheduled' ? 'bg-blue-100 text-blue-800' :
                        order.status === 'in_progress' ? 'bg-yellow-100 text-yellow-800' :
                        'bg-gray-100 text-gray-800'
                      }`}>
                        {order.status === 'completed' ? 'âœ… ZakoÅ„czona' :
                         order.status === 'scheduled' ? 'ğŸ“… Zaplanowana' :
                         order.status === 'in_progress' ? 'ğŸ”„ W trakcie' :
                         order.status}
                      </span>
                    </div>
                    
                    {order.scheduledDate && (
                      <p className="text-sm text-gray-600 mb-1">
                        ğŸ“… {new Date(order.scheduledDate).toLocaleDateString('pl-PL')}
                        {order.scheduledTime && ` o ${order.scheduledTime}`}
                      </p>
                    )}
                    
                    {order.technicianName && (
                      <p className="text-sm text-gray-600">
                        ğŸ‘¤ Technik: {order.technicianName}
                      </p>
                    )}

                    {order.visitNumber === 1 && (
                      <div className="mt-2 pt-2 border-t border-blue-200">
                        <p className="text-xs text-blue-700">
                          ğŸ¯ <strong>To jest wizyta, ktÃ³rÄ… obecnie przeglÄ…dasz</strong>
                        </p>
                      </div>
                    )}

                    {/* Szybka akcja - Edytuj wizytÄ™ */}
                    <div className="mt-3 flex gap-2">
                      <button
                        onClick={() => {
                          const orderId = order.orderId || order.id;
                          router.push(`/zlecenie-szczegoly?id=${orderId}`);
                        }}
                        className="flex-1 px-3 py-1.5 bg-blue-100 text-blue-700 text-xs rounded hover:bg-blue-200 transition-colors flex items-center justify-center gap-1"
                      >
                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                        </svg>
                        Edytuj
                      </button>
                      {order.status !== 'completed' && (
                        <button
                          onClick={() => {
                            alert('Funkcja oznaczania wizyty jako zakoÅ„czonej - wkrÃ³tce!');
                          }}
                          className="flex-1 px-3 py-1.5 bg-green-100 text-green-700 text-xs rounded hover:bg-green-200 transition-colors flex items-center justify-center gap-1"
                        >
                          <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                          </svg>
                          ZakoÅ„cz
                        </button>
                      )}
                    </div>
                  </div>

                  {/* Placeholder dla przyszÅ‚ych wizyt */}
                  <div className="p-4 rounded-lg border-2 border-dashed border-gray-300 bg-gray-50">
                    <div className="flex items-center justify-between mb-2">
                      <span className="font-medium text-gray-600">
                        â• Dodaj kolejnÄ… wizytÄ™
                      </span>
                      <button 
                        className="px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors flex items-center gap-1"
                        onClick={() => {
                          // OtwÃ³rz stronÄ™ edycji zlecenia, gdzie moÅ¼na dodaÄ‡ wizytÄ™
                          const orderId = order.orderId || order.id;
                          router.push(`/zlecenie-szczegoly?id=${orderId}&action=add-visit`);
                        }}
                      >
                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                        </svg>
                        Dodaj wizytÄ™
                      </button>
                    </div>
                    <p className="text-xs text-gray-500">
                      MoÅ¼esz zaplanowaÄ‡ np. naprawÄ™ po diagnozie lub wizytÄ™ kontrolnÄ…
                    </p>
                  </div>
                </div>

                {/* Info box */}
                <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                  <p className="text-xs text-yellow-800">
                    <strong>â„¹ï¸ Jak to dziaÅ‚a:</strong> Jedno zlecenie moÅ¼e mieÄ‡ wiele wizyt. 
                    Klient dzwoni â†’ tworzymy zlecenie â†’ planujemy wizyty (diagnoza, naprawa, kontrola). 
                    Inteligentny planer optymalizuje WIZYTY, nie zlecenia.
                  </p>
                </div>
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="sticky bottom-0 bg-gray-50 p-4 rounded-b-lg border-t flex justify-end gap-3">
            <button
              onClick={() => setShowOrderDetailsModal(false)}
              className="px-6 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
            >
              Zamknij
            </button>
            <button
              onClick={() => {
                console.log('ğŸ”§ Przekierowanie do edycji zlecenia:', order.orderId || order.id);
                // Przekieruj do strony szczegÃ³Å‚Ã³w/edycji zlecenia
                const orderId = order.orderId || order.id;
                router.push(`/zlecenie-szczegoly?id=${orderId}`);
              }}
              className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center gap-2"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
              </svg>
              Edytuj zlecenie
            </button>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* ğŸ†• Modal ze szczegÃ³Å‚ami zlecenia */}
      <OrderDetailsModal />
      {/* Powiadomienia */}
      {notifications.length > 0 && (
        <div className="fixed top-4 right-4 z-50 space-y-2">
          {notifications.map(notification => (
            <div
              key={notification.id}
              className={`p-4 rounded-lg shadow-lg border max-w-sm transition-all duration-300 ${
                notification.type === 'success' ? 'bg-green-50 border-green-200 text-green-800' :
                notification.type === 'warning' ? 'bg-yellow-50 border-yellow-200 text-yellow-800' :
                notification.type === 'error' ? 'bg-red-50 border-red-200 text-red-800' :
                'bg-blue-50 border-blue-200 text-blue-800'
              }`}
            >
              <div className="flex items-start justify-between">
                <div className="flex-1">
                  <p className="text-sm font-medium">{notification.message}</p>
                  <p className="text-xs opacity-75 mt-1">
                    {notification.timestamp.toLocaleTimeString('pl-PL', { 
                      hour: '2-digit', 
                      minute: '2-digit' 
                    })}
                  </p>
                </div>
                <button
                  onClick={() => removeNotification(notification.id)}
                  className="ml-2 text-gray-400 hover:text-gray-600"
                >
                  âœ•
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
      
      {/* Header */}
      <div className="bg-white shadow-sm border-b">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
                <Calendar className="h-8 w-8 text-blue-600" />
                Inteligentny Planer Tygodniowy
              </h1>
              <p className="text-gray-600 mt-1">
                Planowanie wizyt z uwzglÄ™dnieniem dostÄ™pnoÅ›ci klientÃ³w i priorytetÃ³w
              </p>
            </div>
            <div className="flex items-center gap-3">
              {/* Selector serwisanta */}
              <div className="relative">
                <button
                  onClick={() => setShowServicemanSelector(!showServicemanSelector)}
                  className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                  title="Wybierz serwisanta"
                >
                  <Users className="h-4 w-4" />
                  {availableServicemen.find(s => s.id === currentServiceman)?.name || 'Serwisant'}
                </button>
                
                {showServicemanSelector && (
                  <div className="absolute top-full left-0 mt-2 w-64 bg-white rounded-lg shadow-lg border z-50">
                    <div className="p-3 border-b">
                      <h3 className="font-semibold text-gray-900">Wybierz serwisanta</h3>
                      <p className="text-xs text-gray-600 mt-1">KaÅ¼dy serwisant ma osobny planner</p>
                    </div>
                    <div className="p-2">
                      {availableServicemen.map(serviceman => (
                        <button
                          key={serviceman.id}
                          onClick={() => {
                            setCurrentServiceman(serviceman.id);
                            setShowServicemanSelector(false);
                            // Oznacz serwisanta jako aktywnego
                            setAvailableServicemen(prev => prev.map(s => ({
                              ...s,
                              isActive: s.id === serviceman.id
                            })));
                            // âœ… PrzeÅ‚aduj plan dla nowego serwisanta
                            console.log('ğŸ”„ Zmieniono serwisanta na:', serviceman.id);
                            setTimeout(() => loadIntelligentPlan(), 100);
                          }}
                          className={`w-full flex items-center gap-3 p-3 rounded-lg text-left hover:bg-gray-50 ${
                            currentServiceman === serviceman.id ? 'bg-blue-50 border border-blue-200' : ''
                          }`}
                        >
                          <div 
                            className="w-4 h-4 rounded-full" 
                            style={{ backgroundColor: serviceman.color }}
                          ></div>
                          <div className="flex-1">
                            <div className="font-medium text-gray-900">{serviceman.name}</div>
                            <div className="text-xs text-gray-500">
                              {serviceman.isActive ? 'Aktywny' : 'DostÄ™pny'}
                            </div>
                          </div>
                          {currentServiceman === serviceman.id && (
                            <CheckCircle className="h-4 w-4 text-blue-600" />
                          )}
                        </button>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
          
          {/* Aktualna lokalizacja startowa */}
          <div className="mt-3 p-3 bg-gray-50 rounded-lg">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <MapPin className="h-4 w-4 text-gray-600" />
                <span className="text-sm font-medium text-gray-700">Punkt startowy:</span>
                <span className="text-sm text-gray-900">{startLocation.address}</span>
                {startLocation.isDetected && (
                  <span className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">
                    ğŸ“ Wykryto automatycznie
                  </span>
                )}
              </div>
            </div>
          </div>
          
          {/* Panel ustawieÅ„ godzin pracy */}
          <div className="mt-3 p-4 bg-orange-50 rounded-lg border border-orange-200">
            <h3 className="font-semibold text-orange-800 mb-3 flex items-center gap-2">
              <Clock className="h-4 w-4" />
              Godziny Pracy - {availableServicemen.find(s => s.id === currentServiceman)?.name}
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  RozpoczÄ™cie pracy
                </label>
                <input
                  type="time"
                  value={optimizationPreferences.workingHours.start}
                  onChange={(e) => setOptimizationPreferences(prev => ({
                    ...prev,
                    workingHours: { ...prev.workingHours, start: e.target.value }
                  }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  ZakoÅ„czenie pracy
                </label>
                <input
                  type="time"
                  value={optimizationPreferences.workingHours.end}
                  onChange={(e) => setOptimizationPreferences(prev => ({
                    ...prev,
                    workingHours: { ...prev.workingHours, end: e.target.value }
                  }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Max godzin dziennie
                </label>
                <select
                  value={optimizationPreferences.workingHours.maxWorkingHours}
                  onChange={(e) => setOptimizationPreferences(prev => ({
                    ...prev,
                    workingHours: { ...prev.workingHours, maxWorkingHours: parseInt(e.target.value) }
                  }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500"
                >
                  <option value={8}>8 godzin</option>
                  <option value={10}>10 godzin</option>
                  <option value={12}>12 godzin</option>
                  <option value={14}>14 godzin</option>
                </select>
              </div>
            </div>
            <div className="mt-3 text-xs text-orange-600">
              âš ï¸ System zapewni, Å¼e harmonogram nie przekroczy tych limitÃ³w podczas przenoszenia zleceÅ„
            </div>
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-6">
        {/* Analiza kosztÃ³w */}
        {weeklyPlan.costAnalysis && weeklyPlan.costAnalysis.optimized && (
          <div className="mb-6 bg-white rounded-lg shadow-sm p-6">
            <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
              <DollarSign className="h-5 w-5 text-green-600" />
              Analiza KosztÃ³w i OszczÄ™dnoÅ›ci
            </h2>
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
              <div className="text-center p-4 bg-green-50 rounded-lg">
                <div className="text-2xl font-bold text-green-600">
                  {weeklyPlan.costAnalysis.savings}zÅ‚
                </div>
                <div className="text-sm text-gray-600">OszczÄ™dnoÅ›ci</div>
                <div className="text-xs text-green-600 font-medium">
                  {weeklyPlan.costAnalysis.savingsPercentage}% taniej
                </div>
              </div>
              <div className="text-center p-4 bg-blue-50 rounded-lg">
                <div className="text-2xl font-bold text-blue-600">
                  {weeklyPlan.costAnalysis.optimized.totalDistance}km
                </div>
                <div className="text-sm text-gray-600">CaÅ‚kowity dystans</div>
                <div className="text-xs text-blue-600 font-medium">
                  {weeklyPlan.costAnalysis.optimized.totalFuelCost}zÅ‚ paliwa
                </div>
              </div>
              <div className="text-center p-4 bg-purple-50 rounded-lg">
                <div className="text-2xl font-bold text-purple-600">
                  {weeklyPlan.costAnalysis.optimized.totalRevenue}zÅ‚
                </div>
                <div className="text-sm text-gray-600">PrzychÃ³d</div>
                <div className="text-xs text-purple-600 font-medium">
                  {weeklyPlan.costAnalysis.optimized.profit}zÅ‚ zysku
                </div>
              </div>
              <div className="text-center p-4 bg-orange-50 rounded-lg">
                <div className="text-2xl font-bold text-orange-600">
                  {weeklyPlan.costAnalysis.efficiency}%
                </div>
                <div className="text-sm text-gray-600">EfektywnoÅ›Ä‡</div>
                <div className="text-xs text-orange-600 font-medium">
                  MarÅ¼a zysku
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Rekomendacje */}
        {weeklyPlan.recommendations && weeklyPlan.recommendations.length > 0 && (
          <div className="mb-6 bg-white rounded-lg shadow-sm p-6">
            <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
              <AlertTriangle className="h-5 w-5 text-yellow-600" />
              Rekomendacje Systemu
            </h2>
            <div className="space-y-3">
              {weeklyPlan.recommendations.map((rec, idx) => (
                <div key={idx} className={`p-3 rounded-lg border-l-4 ${
                  rec.priority === 'high' ? 'bg-red-50 border-red-400' :
                  rec.priority === 'medium' ? 'bg-yellow-50 border-yellow-400' :
                  'bg-blue-50 border-blue-400'
                }`}>
                  <div className="flex items-start gap-3">
                    <div className={`mt-1 ${
                      rec.type === 'warning' ? 'text-yellow-600' :
                      rec.type === 'optimization' ? 'text-blue-600' :
                      'text-green-600'
                    }`}>
                      {rec.type === 'warning' ? <AlertTriangle className="h-4 w-4" /> :
                       rec.type === 'optimization' ? <TrendingUp className="h-4 w-4" /> :
                       <CheckCircle className="h-4 w-4" />}
                    </div>
                    <p className="text-sm font-medium">{rec.message}</p>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Nawigacja tygodniowa */}
        <div className="mb-6 bg-white rounded-lg shadow-sm p-4">
          <div className="flex items-center justify-between">
            <button
              onClick={() => {
                const newWeekStart = new Date(currentWeekStart);
                newWeekStart.setDate(currentWeekStart.getDate() - 7);
                setCurrentWeekStart(newWeekStart);
              }}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
            >
              <ChevronLeft className="h-4 w-4" />
              Poprzedni tydzieÅ„
            </button>
            
            <div className="text-center">
              <h2 className="text-lg font-semibold">
                TydzieÅ„ {currentWeekStart.toLocaleDateString('pl-PL', { 
                  day: '2-digit', 
                  month: '2-digit',
                  year: 'numeric'
                })} - {(() => {
                  const weekEnd = new Date(currentWeekStart);
                  weekEnd.setDate(currentWeekStart.getDate() + 6);
                  return weekEnd.toLocaleDateString('pl-PL', { 
                    day: '2-digit', 
                    month: '2-digit',
                    year: 'numeric'
                  });
                })()}
              </h2>
              <p className="text-sm text-gray-600">
                {(() => {
                  const today = new Date();
                  const weekStart = new Date(currentWeekStart);
                  weekStart.setHours(0, 0, 0, 0);
                  today.setHours(0, 0, 0, 0);
                  
                  if (weekStart.getTime() === today.getTime() - (today.getDay() === 0 ? 6 : today.getDay() - 1) * 24 * 60 * 60 * 1000) {
                    return "Obecny tydzieÅ„";
                  } else if (weekStart.getTime() > today.getTime()) {
                    return "PrzyszÅ‚y tydzieÅ„";
                  } else {
                    return "Miniony tydzieÅ„";
                  }
                })()}
              </p>
            </div>
            
            <button
              onClick={() => {
                const newWeekStart = new Date(currentWeekStart);
                newWeekStart.setDate(currentWeekStart.getDate() + 7);
                setCurrentWeekStart(newWeekStart);
              }}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
            >
              NastÄ™pny tydzieÅ„
              <ChevronRight className="h-4 w-4" />
            </button>
          </div>
        </div>
        
        {/* Toolbar z opcjami widoku */}
        <div className="mb-6 bg-white rounded-lg shadow-sm p-4">
          <div className="flex flex-col lg:flex-row gap-4 items-start lg:items-center justify-between">
            {/* Opcje widoku */}
            <div className="flex flex-wrap items-center gap-4">
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium text-gray-700">Widok:</span>
                <div className="flex border rounded-lg overflow-hidden">
                  {[1, 2, 3, 4, 5, 7].map(cols => (
                    <button
                      key={cols}
                      onClick={() => setViewMode(cols)}
                      className={`px-3 py-1 text-xs font-medium transition-colors ${
                        viewMode === cols 
                          ? 'bg-blue-600 text-white' 
                          : 'bg-white text-gray-700 hover:bg-gray-50'
                      }`}
                      title={`${cols} ${cols === 1 ? 'kolumna' : cols < 5 ? 'kolumny' : 'kolumn'}`}
                    >
                      {cols}
                    </button>
                  ))}
                </div>
              </div>

              {/* Zakres godzin timeline */}
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium text-gray-700">Godziny:</span>
                <select
                  value={`${timeRange.start}-${timeRange.end}`}
                  onChange={(e) => {
                    const [start, end] = e.target.value.split('-').map(Number);
                    setTimeRange({ start, end });
                  }}
                  className="text-xs border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  title="Wybierz zakres godzin wyÅ›wietlanych na osi czasu"
                >
                  <option value="0-24">00:00 - 24:00 (caÅ‚Ä… dobÄ™)</option>
                  <option value="6-23">06:00 - 23:00 (domyÅ›lnie)</option>
                  <option value="7-22">07:00 - 22:00 (godziny pracy)</option>
                  <option value="8-20">08:00 - 20:00 (standard)</option>
                  <option value="8-18">08:00 - 18:00 (biznesowe)</option>
                  <option value="9-17">09:00 - 17:00 (biurowe)</option>
                </select>
                <label className="flex items-center gap-1 text-xs text-gray-700 cursor-pointer hover:text-blue-600 transition-colors">
                  <input
                    type="checkbox"
                    checked={hideUnusedHours}
                    onChange={(e) => setHideUnusedHours(e.target.checked)}
                    className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                    title="Ukryj godziny poza wybranym zakresem (zwiÅ„ timeline)"
                  />
                  <span className="whitespace-nowrap">Ukryj niewykorzystane</span>
                </label>
              </div>

              {/* NagÅ‚Ã³wek karty */}
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium text-gray-700">NagÅ‚Ã³wek:</span>
                <select
                  value={cardHeaderField}
                  onChange={(e) => setCardHeaderField(e.target.value)}
                  className="text-xs border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  title="Wybierz, co ma byÄ‡ wyÅ›wietlane jako nagÅ‚Ã³wek karty zlecenia"
                >
                  <option value="clientName">ImiÄ™ i nazwisko</option>
                  <option value="address">Adres</option>
                  <option value="deviceType">Typ sprzÄ™tu</option>
                  <option value="description">Problem/Opis</option>
                </select>
              </div>

              {/* Sortowanie */}
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium text-gray-700">Sortuj:</span>
                <select
                  value={sortBy}
                  onChange={(e) => setSortBy(e.target.value)}
                  className="text-xs border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="default">DomyÅ›lnie</option>
                  <option value="priority">Priorytet</option>
                  <option value="time">Czas realizacji</option>
                  <option value="revenue">WartoÅ›Ä‡ zlecenia</option>
                  <option value="client">Nazwa klienta</option>
                </select>
              </div>

              {/* Filtrowanie */}
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium text-gray-700">Filtruj:</span>
                <select
                  value={filterBy}
                  onChange={(e) => setFilterBy(e.target.value)}
                  className="text-xs border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="all">Wszystkie</option>
                  <option value="high">Pilne</option>
                  <option value="medium">Åšrednie</option>
                  <option value="low">Niskie</option>
                  <option value="completed">Wykonane</option>
                  <option value="pending">OczekujÄ…ce</option>
                </select>
              </div>
            </div>

            {/* Statystyki i dodatkowe opcje */}
            <div className="flex flex-wrap items-center gap-4 text-xs text-gray-600">
              <span className="flex items-center gap-1">
                ğŸ“Š {Object.values(getWeeklyPlanData(weeklyPlan) || {}).reduce((sum, day) => sum + (day?.orders?.length || 0), 0)} zleceÅ„
              </span>
              <span className="flex items-center gap-1">
                ğŸ’° {Object.values(getWeeklyPlanData(weeklyPlan) || {}).reduce((sum, day) => 
                  sum + (day?.orders?.reduce((daySum, order) => daySum + (order.serviceCost || 0), 0) || 0), 0
                )} zÅ‚
              </span>
              {expandedDay && (
                <div className="flex items-center gap-2 ml-4">
                  <span className="text-sm font-medium">Widok:</span>
                  <select
                    value={ordersPerPage}
                    onChange={(e) => setOrdersPerPage(Number(e.target.value))}
                    className="text-xs border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value={5}>5 na stronÄ™</option>
                    <option value={10}>10 na stronÄ™</option>
                    <option value={20}>20 na stronÄ™</option>
                    <option value={50}>50 na stronÄ™</option>
                  </select>
                </div>
              )}
              {expandedDay && (
                <button
                  onClick={() => setExpandedDay(null)}
                  className="flex items-center gap-1 px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200"
                  title="Zamknij rozwiniÄ™ty widok"
                >
                  <svg className="h-3 w-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                  Zamknij
                </button>
              )}
            </div>
          </div>
        </div>

        {/* Backdrop dla rozwiniÄ™tego widoku */}
        {expandedDay && (
          <div 
            className="fixed inset-0 bg-black bg-opacity-50 z-40"
            onClick={() => setExpandedDay(null)}
          />
        )}

        {/* Pula niezapisanych zleceÅ„ */}
        {(() => {
          // ZnajdÅº wszystkie zlecenia bez przypisanego dnia (scheduledDate === null)
          const unscheduledOrders = weeklyPlan.unscheduledOrders || [];
          
          // âœ… ZAWSZE POKAZUJ SEKCJÄ˜ - nawet gdy pusta (Å¼eby moÅ¼na byÅ‚o przeciÄ…gaÄ‡ zlecenia z powrotem)
          return (
            <div 
              className="mb-6 bg-gradient-to-r from-orange-50 to-yellow-50 rounded-lg shadow-sm border-2 border-orange-200 h-[300px] flex flex-col"
              onDragOver={(e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
              }}
              onDrop={async (e) => {
                e.preventDefault();
                if (draggedOrder && draggedOrder.sourceDay !== 'unscheduled') {
                  await moveOrderToUnscheduled(draggedOrder.order, draggedOrder.sourceDay);
                }
              }}
            >
              <div className="flex items-center justify-between p-4 flex-shrink-0">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-orange-500 text-white rounded-lg">
                    <Calendar className="h-5 w-5" />
                  </div>
                  <div>
                    <h2 className="text-lg font-semibold text-orange-900">
                      ğŸ“¦ Niezaplanowane zlecenia ({unscheduledOrders.length})
                    </h2>
                    <p className="text-sm text-orange-700">
                      PrzeciÄ…gnij zlecenie na wybrany dzieÅ„ tygodnia, aby je zaplanowaÄ‡
                    </p>
                  </div>
                </div>
                <button
                  onClick={() => {
                    // Automatycznie zaplanuj wszystkie zlecenia
                    showNotification('ğŸ¤– Automatyczne planowanie...', 'info');
                    loadIntelligentPlan();
                  }}
                  className="flex items-center gap-2 px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition-colors"
                  title="Automatycznie rozplanuj wszystkie zlecenia"
                >
                  <Bot className="h-4 w-4" />
                  Auto-plan
                </button>
              </div>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 overflow-y-auto px-4 pb-4 flex-1">
                {unscheduledOrders.length === 0 ? (
                  <div className="col-span-full flex flex-col items-center justify-center h-full text-gray-500">
                    <Calendar className="h-16 w-16 mb-4 opacity-30" />
                    <p className="text-lg font-medium">Wszystkie zlecenia zostaÅ‚y zaplanowane! ğŸ‰</p>
                    <p className="text-sm mt-2">PrzeciÄ…gnij zlecenie tutaj aby cofnÄ…Ä‡ planowanie</p>
                  </div>
                ) : (
                  unscheduledOrders.map((order) => (
                  <div
                    key={order.id}
                    className={`p-4 bg-white rounded-lg border-2 shadow-sm hover:shadow-md transition-all cursor-move ${
                      priorityColors[order.priority] || 'border-gray-300'
                    }`}
                    draggable={true}
                    onDragStart={(e) => handleDragStart(e, order, 'unscheduled')}
                    onDragEnd={handleDragEnd}
                    title="PrzeciÄ…gnij to zlecenie na wybrany dzieÅ„"
                  >
                    <div className="flex items-start justify-between mb-2 gap-2">
                      <div className="flex-1 min-w-0">
                        <h4 
                          className="font-semibold text-gray-900 text-sm truncate"
                          title={getCardHeaderText(order)}
                        >
                          {getCardHeaderText(order)}
                        </h4>
                        <p className="text-xs text-gray-600 mt-1 truncate">
                          {order.deviceType} {order.brand && `- ${order.brand}`}
                        </p>
                      </div>
                      <span className={`text-xs px-2 py-1 rounded-full font-medium whitespace-nowrap flex-shrink-0 ${
                        order.priority === 'urgent' ? 'bg-red-100 text-red-800' :
                        order.priority === 'high' ? 'bg-orange-100 text-orange-800' :
                        order.priority === 'medium' ? 'bg-yellow-100 text-yellow-800' :
                        'bg-green-100 text-green-800'
                      }`}>
                        {order.priority === 'urgent' ? 'ğŸ”¥ Pilne' :
                         order.priority === 'high' ? 'âš¡ Wysokie' :
                         order.priority === 'medium' ? 'ğŸ“Œ Åšrednie' :
                         'âœ… Niskie'}
                      </span>
                    </div>
                    
                    <div className="text-xs text-gray-600 mb-2 line-clamp-2">
                      {order.description || order.problemDescription || 'Brak opisu'}
                    </div>
                    
                    <div className="flex items-center justify-between text-xs text-gray-500">
                      <span className="flex items-center gap-1">
                        <Clock className="h-3 w-3" />
                        {order.estimatedDuration || 60} min
                      </span>
                      <span className="flex items-center gap-1">
                        <DollarSign className="h-3 w-3" />
                        {order.serviceCost || 150} zÅ‚
                      </span>
                    </div>
                    
                    {order.address && (
                      <div className="mt-2 pt-2 border-t border-gray-200">
                        <p className="text-xs text-gray-600 truncate" title={order.address}>
                          ğŸ“ {order.address}
                        </p>
                      </div>
                    )}
                    
                    {order.preferredDate && (
                      <div className="mt-2 text-xs text-blue-600 font-medium">
                        Preferowana: {new Date(order.preferredDate).toLocaleDateString('pl-PL')}
                      </div>
                    )}
                  </div>
                  ))
                )}
              </div>
            </div>
          );
        })()}

        {/* Plan tygodniowy z datami */}
        <div className={`grid gap-6 h-[calc(100vh-500px)] ${
          expandedDay ? 'grid-cols-1' : 
          viewMode === 1 ? 'grid-cols-1' :
          viewMode === 2 ? 'grid-cols-1 md:grid-cols-2' :
          viewMode === 3 ? 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3' :
          viewMode === 4 ? 'grid-cols-1 md:grid-cols-2 lg:grid-cols-4' :
          viewMode === 5 ? 'grid-cols-1 md:grid-cols-2 lg:grid-cols-5' :
          'grid-cols-1 md:grid-cols-2 lg:grid-cols-7'
        }`}>
          {Object.keys(dayNames).map(day => {
            const dayPlan = weeklyPlan[day] || { orders: [], stats: {} };
            const dayOrders = getOrdersForWeekDay(day); // ğŸ†• UÅ¼yj funkcji filtrujÄ…cej zamiast dayPlan.orders
            const dayInfo = formatDayWithDate(day, currentWeekStart);
            
            return (
              <div key={day} className={`bg-white rounded-lg shadow-sm flex flex-col ${
                dayInfo.isToday ? 'ring-2 ring-blue-400 bg-blue-50' : 
                dayInfo.isPast ? 'opacity-75' : ''
              }`}>
                <div className="p-4 border-b border-gray-200 h-[140px] flex-shrink-0 flex flex-col justify-between">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className={`font-semibold text-lg ${dayInfo.isToday ? 'text-blue-700' : ''}`}>
                        {dayInfo.name}
                      </h3>
                      <p className={`text-sm ${dayInfo.isToday ? 'text-blue-600 font-medium' : 'text-gray-500'}`}>
                        {dayInfo.date}
                        {dayInfo.isToday && <span className="ml-2 px-2 py-1 bg-blue-200 text-blue-800 text-xs rounded-full">DziÅ›</span>}
                        {dayInfo.isPast && <span className="ml-2 px-2 py-1 bg-gray-200 text-gray-600 text-xs rounded-full">PrzeszÅ‚oÅ›Ä‡</span>}
                      </p>
                    </div>
                    <span className="text-sm text-gray-500">
                      {dayOrders.length} {dayOrders.length === 1 ? 'zlecenie' : 'zleceÅ„'}
                    </span>
                  </div>
                  
                  {dayOrders.length > 0 && (
                    <div className="flex items-center gap-1 flex-wrap">
                      <button
                        onClick={() => optimizeSingleDay(day)}
                        className="flex items-center gap-1 px-2 py-1 bg-purple-600 text-white text-[10px] rounded hover:bg-purple-700 transition-colors whitespace-nowrap"
                        title="Optymalizuj tylko ten dzieÅ„"
                      >
                        <TrendingUp className="h-3 w-3" />
                        <span className="hidden lg:inline">Opt.</span>
                      </button>
                      <button
                        onClick={() => setSelectedDay(selectedDay === day ? null : day)}
                        className="flex items-center gap-1 px-2 py-1 bg-gray-600 text-white text-[10px] rounded hover:bg-gray-700 transition-colors whitespace-nowrap"
                      >
                        <Settings className="h-3 w-3" />
                        <span className="hidden md:inline">{selectedDay === day ? 'Ukryj' : 'Szczeg.'}</span>
                      </button>
                    </div>
                  )}
                </div>
                
                {/* ğŸ“… Timeline z osiÄ… czasu i zleceniami */}
                {(() => {
                  const schedule = getServicemanScheduleForDay(day, currentServiceman);
                  
                  // Konwersja czasu na procent wysokoÅ›ci (0-100%)
                  const timeToPixels = (time) => {
                    const [h, m] = time.split(':').map(Number);
                    const totalMinutes = h * 60 + m;
                    
                    if (hideUnusedHours) {
                      // Tryb zwiniÄ™ty - mapuj tylko zakres timeRange.start do timeRange.end na 0-100%
                      const rangeMinutes = (timeRange.end - timeRange.start) * 60;
                      const offsetMinutes = totalMinutes - (timeRange.start * 60);
                      return (offsetMinutes / rangeMinutes) * 100;
                    } else {
                      // Tryb peÅ‚ny - mapuj 0-24h na 0-100%
                      return (totalMinutes / (24 * 60)) * 100;
                    }
                  };
                  
                  // Pobierz czas rozpoczÄ™cia wizyty z zlecenia
                  const getOrderStartTime = (order) => {
                    // SprawdÅº czy zlecenie ma zapisany czas wizyty
                    if (order.scheduledTime) return order.scheduledTime;
                    if (order.preferredTime) return order.preferredTime;
                    // JeÅ›li brak - uÅ¼yj domyÅ›lnego (8:00)
                    return '08:00';
                  };
                  
                  const getOrderDuration = (order) => {
                    return order.estimatedDuration || 60; // minuty
                  };
                  
                  // Oblicz czas zakoÅ„czenia
                  const getOrderEndTime = (order) => {
                    const startTime = getOrderStartTime(order);
                    const duration = getOrderDuration(order);
                    const [h, m] = startTime.split(':').map(Number);
                    const totalMinutes = h * 60 + m + duration;
                    const endH = Math.floor(totalMinutes / 60);
                    const endM = totalMinutes % 60;
                    return `${endH.toString().padStart(2, '0')}:${endM.toString().padStart(2, '0')}`;
                  };
                  
                  // Funkcja do obsÅ‚ugi upuszczenia zlecenia na timeline (zmiana godziny/dnia)
                  const handleTimelineDrop = async (e, targetDay, mouseY) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (!draggedOrder) return;
                    
                    // Oblicz godzinÄ™ na podstawie pozycji Y myszy
                    const rect = e.currentTarget.getBoundingClientRect();
                    const relativeY = mouseY - rect.top;
                    const percentY = (relativeY / rect.height) * 100;
                    
                    let totalMinutes;
                    if (hideUnusedHours) {
                      // Tryb zwiniÄ™ty - mapuj 0-100% na zakres timeRange
                      const rangeMinutes = (timeRange.end - timeRange.start) * 60;
                      totalMinutes = (timeRange.start * 60) + (percentY / 100) * rangeMinutes;
                    } else {
                      // Tryb peÅ‚ny - mapuj 0-100% na 0-24h
                      totalMinutes = (percentY / 100) * 24 * 60;
                    }
                    
                    const hour = Math.floor(totalMinutes / 60);
                    const minute = Math.floor((totalMinutes % 60) / 15) * 15; // ZaokrÄ…glij do 15 min
                    const newTime = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                    
                    console.log(`ğŸ“ Upuszczono zlecenie na ${targetDay} o godzinie ${newTime}`);
                    
                    // Aktualizuj zlecenie z nowÄ… datÄ… i godzinÄ…
                    const targetDate = getDateForDay(targetDay);
                    const dateStr = targetDate.toISOString().split('T')[0];
                    
                    // âœ… OPTYMISTYCZNA AKTUALIZACJA STANU (przed zapisem do API)
                    const updatedOrder = {
                      ...draggedOrder.order,
                      scheduledDate: dateStr,
                      scheduledTime: newTime
                    };
                    
                    // âœ… Aktualizuj stan lokalny natychmiast - NOWA STRUKTURA
                    setWeeklyPlan(prevPlan => {
                      const newPlan = { ...prevPlan };
                      
                      // UsuÅ„ ze starego miejsca
                      if (draggedOrder.sourceDay === 'unscheduled') {
                        newPlan.unscheduledOrders = newPlan.unscheduledOrders.filter(o => o.id !== draggedOrder.order.id);
                      } else if (draggedOrder.sourceDay && newPlan[draggedOrder.sourceDay]) {
                        // UsuÅ„ z dnia ÅºrÃ³dÅ‚owego
                        const sourceOrders = [...(newPlan[draggedOrder.sourceDay].orders || [])];
                        newPlan[draggedOrder.sourceDay].orders = sourceOrders.filter(o => o.id !== draggedOrder.order.id);
                      }
                      
                      // Dodaj do docelowego dnia w weeklyPlan[targetDay].orders
                      if (newPlan[targetDay]) {
                        const targetOrders = [...(newPlan[targetDay].orders || [])];
                        newPlan[targetDay].orders = [...targetOrders, updatedOrder];
                      }
                      
                      return newPlan;
                    });
                    
                    try {
                      const response = await fetch(`/api/orders/${draggedOrder.order.id}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                          scheduledDate: dateStr,
                          scheduledTime: newTime
                        })
                      });
                      
                      if (response.ok) {
                        showNotification(`âœ… Zlecenie przeniesione na ${targetDay} o ${newTime}`, 'success');
                        // Nie Å‚aduj ponownie caÅ‚ego planu - juÅ¼ zaktualizowaliÅ›my lokalnie
                      } else {
                        // JeÅ›li API zwrÃ³ciÅ‚o bÅ‚Ä…d, cofnij zmiany
                        showNotification('âŒ Nie udaÅ‚o siÄ™ zapisaÄ‡ zmian', 'error');
                        await loadIntelligentPlan(); // PrzywrÃ³Ä‡ z API
                      }
                    } catch (error) {
                      console.error('BÅ‚Ä…d aktualizacji zlecenia:', error);
                      showNotification('âŒ Nie udaÅ‚o siÄ™ przenieÅ›Ä‡ zlecenia', 'error');
                      await loadIntelligentPlan(); // PrzywrÃ³Ä‡ z API
                    }
                    
                    setDraggedOrder(null);
                    setIsDragging(false);
                    setDragOverInfo(null);
                  };
                  
                  return (
                    <div 
                      className="relative flex-1 bg-gray-50 border-b border-gray-200 overflow-y-auto min-h-[1600px]"
                      onDragOver={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // PokaÅ¼ podglÄ…d gdzie zlecenie zostanie upuszczone
                        if (isDragging) {
                          const rect = e.currentTarget.getBoundingClientRect();
                          const relativeY = e.clientY - rect.top;
                          const percentY = (relativeY / rect.height) * 100;
                          
                          let totalMinutes;
                          if (hideUnusedHours) {
                            // Tryb zwiniÄ™ty
                            const rangeMinutes = (timeRange.end - timeRange.start) * 60;
                            totalMinutes = (timeRange.start * 60) + (percentY / 100) * rangeMinutes;
                          } else {
                            // Tryb peÅ‚ny
                            totalMinutes = (percentY / 100) * 24 * 60;
                          }
                          
                          const hour = Math.floor(totalMinutes / 60);
                          const minute = Math.floor((totalMinutes % 60) / 15) * 15;
                          const time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                          
                          setDragOverInfo({ y: percentY, time, day });
                        }
                      }}
                      onDragLeave={() => setDragOverInfo(null)}
                      onDrop={(e) => {
                        handleTimelineDrop(e, day, e.clientY);
                        setDragOverInfo(null);
                      }}
                    >
                      {/* Linia podglÄ…du podczas przeciÄ…gania */}
                      {dragOverInfo && dragOverInfo.day === day && (
                        <div
                          className="absolute w-full border-t-2 border-dashed border-purple-500 z-30 pointer-events-none"
                          style={{ top: `${dragOverInfo.y}%` }}
                        >
                          <span className="absolute right-2 -top-3 text-xs font-bold text-purple-600 bg-purple-100 px-2 py-0.5 rounded shadow-sm">
                            ğŸ“ {dragOverInfo.time}
                          </span>
                        </div>
                      )}
                      {/* Siatka godzin - dynamiczny zakres z liniami co 30 min */}
                      {Array.from({ length: (timeRange.end - timeRange.start) * 2 }, (_, i) => {
                        const totalMinutes = (timeRange.start * 60) + (i * 30); // Start at selected hour, increment by 30 min
                        const h = Math.floor(totalMinutes / 60);
                        const m = totalMinutes % 60;
                        const isFullHour = m === 0;
                        
                        // Oblicz pozycjÄ™ - w trybie zwiniÄ™tym mapuj na 0-100%, w peÅ‚nym na pozycjÄ™ w dobie
                        let positionPercent;
                        if (hideUnusedHours) {
                          // Tryb zwiniÄ™ty - linie rÃ³wnomiernie rozÅ‚oÅ¼one 0-100%
                          positionPercent = (i / ((timeRange.end - timeRange.start) * 2)) * 100;
                        } else {
                          // Tryb peÅ‚ny - pozycja wzglÄ™dem caÅ‚ej doby (0-24h)
                          positionPercent = (totalMinutes / (24 * 60)) * 100;
                        }
                        
                        return (
                          <div
                            key={`grid-${h}-${m}`}
                            className={`absolute w-full pointer-events-none ${
                              isFullHour ? 'border-t-2 border-gray-300' : 'border-t border-gray-200 border-dashed'
                            }`}
                            style={{ top: `${positionPercent}%` }}
                          >
                            {isFullHour && (
                              <span className="text-[11px] text-gray-600 ml-1 bg-gray-50 px-1.5 py-0.5 font-semibold rounded shadow-sm">
                                {h.toString().padStart(2, '0')}:00
                              </span>
                            )}
                            {!isFullHour && (
                              <span className="text-[9px] text-gray-400 ml-1 bg-gray-50/80 px-1">
                                {h.toString().padStart(2, '0')}:{m.toString().padStart(2, '0')}
                              </span>
                            )}
                          </div>
                        );
                      })}
                      
                      {/* Przyciemnienie godzin poza zakresem - tylko w trybie peÅ‚nym */}
                      {!hideUnusedHours && timeRange.start > 0 && (
                        <div 
                          className="absolute w-full bg-gray-900 opacity-10 pointer-events-none z-10"
                          style={{
                            top: 0,
                            height: `${(timeRange.start / 24) * 100}%`
                          }}
                          title={`Ukryto godziny: 00:00 - ${timeRange.start.toString().padStart(2, '0')}:00`}
                        />
                      )}
                      {!hideUnusedHours && timeRange.end < 24 && (
                        <div 
                          className="absolute w-full bg-gray-900 opacity-10 pointer-events-none z-10"
                          style={{
                            top: `${(timeRange.end / 24) * 100}%`,
                            height: `${((24 - timeRange.end) / 24) * 100}%`
                          }}
                          title={`Ukryto godziny: ${timeRange.end.toString().padStart(2, '0')}:00 - 24:00`}
                        />
                      )}
                      
                      {/* TÅ‚o dostÄ™pnoÅ›ci serwisanta (pÃ³Å‚przezroczyste zielone) */}
                      {schedule && schedule.workSlots && schedule.workSlots.map((slot, idx) => (
                        <div
                          key={`work-${day}-${idx}`}
                          className="absolute w-full bg-green-100 opacity-30 pointer-events-none"
                          style={{
                            top: `${timeToPixels(slot.startTime)}%`,
                            height: `${timeToPixels(slot.endTime) - timeToPixels(slot.startTime)}%`
                          }}
                        />
                      ))}
                      
                      {/* Przerwy serwisanta (pÃ³Å‚przezroczyste pomaraÅ„czowe) */}
                      {schedule && schedule.breaks && schedule.breaks.map((breakSlot, idx) => (
                        <div
                          key={`break-${day}-${idx}`}
                          className="absolute w-full bg-orange-200 opacity-40 pointer-events-none"
                          style={{
                            top: `${timeToPixels(breakSlot.startTime)}%`,
                            height: `${timeToPixels(breakSlot.endTime) - timeToPixels(breakSlot.startTime)}%`
                          }}
                        />
                      ))}
                      
                      {/* ğŸ• LINIA AKTUALNEJ GODZINY */}
                      {(() => {
                        const now = currentTime;
                        const currentHour = now.getHours();
                        const currentMinute = now.getMinutes();
                        const currentTimeString = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
                        
                        // SprawdÅº czy aktualna godzina jest w zakresie wyÅ›wietlanym
                        const isInRange = currentHour >= timeRange.start && currentHour < timeRange.end;
                        
                        if (!isInRange && hideUnusedHours) {
                          return null; // Nie pokazuj linii jeÅ›li jest poza zakresem w trybie zwiniÄ™tym
                        }
                        
                        const currentPosition = timeToPixels(currentTimeString);
                        
                        return (
                          <div
                            key={`current-time-${day}`}
                            className="absolute w-full pointer-events-none z-30"
                            style={{ top: `${currentPosition}%` }}
                          >
                            {/* Czerwona linia */}
                            <div className="absolute w-full h-0.5 bg-red-500 shadow-lg"></div>
                            {/* Czerwony kÃ³Å‚ko po lewej */}
                            <div className="absolute -left-1 -top-1.5 w-3 h-3 bg-red-500 rounded-full shadow-lg"></div>
                            {/* Etykieta z czasem */}
                            <div className="absolute left-4 -top-2.5 bg-red-500 text-white text-[10px] font-bold px-2 py-0.5 rounded shadow-lg">
                              TERAZ {currentTimeString}
                            </div>
                          </div>
                        );
                      })()}
                      
                      {/* ZLECENIA na timeline - PRZECIÄ„GALNE */}
                      {dayOrders.map((order) => {
                        const startTime = getOrderStartTime(order);
                        const endTime = getOrderEndTime(order);
                        const duration = getOrderDuration(order);
                        const heightPercent = timeToPixels(endTime) - timeToPixels(startTime);
                        
                        // Oblicz rzeczywistÄ… wysokoÅ›Ä‡ w pikselach (1600px * heightPercent / 100)
                        const heightPx = Math.max(50, (1600 * heightPercent) / 100);
                        
                        return (
                          <div
                            key={`timeline-${day}-${order.id}`}
                            className="absolute w-full px-2 z-20 cursor-move group"
                            style={{
                              top: `${timeToPixels(startTime)}%`,
                              height: `${heightPercent}%`,
                              minHeight: '50px' // Minimum dla czytelnoÅ›ci
                            }}
                            title={`${startTime} - ${endTime} (${duration} min)\nPrzeciÄ…gnij aby zmieniÄ‡ godzinÄ™ lub dzieÅ„`}
                            draggable={true}
                            onDragStart={(e) => {
                              handleDragStart(e, order, day);
                              e.currentTarget.style.opacity = '0.5';
                            }}
                            onDragEnd={(e) => {
                              handleDragEnd(e);
                              e.currentTarget.style.opacity = '1';
                            }}
                          >
                            <div className={`h-full rounded-lg shadow-lg border-4 p-2 bg-white group-hover:shadow-xl transition-all overflow-hidden cursor-move ${
                              order.priority === 'urgent' ? 'border-red-500 bg-red-200' :
                              order.priority === 'high' ? 'border-orange-500 bg-orange-200' :
                              order.priority === 'medium' ? 'border-yellow-500 bg-yellow-200' :
                              'border-blue-500 bg-blue-200'
                            }`}>
                              {/* Ikona przeciÄ…gania */}
                              <div className="absolute top-1 right-1 text-gray-400 text-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                â‹®â‹®
                              </div>
                              
                              <div className="flex items-start justify-between mb-1">
                                <div className="flex-1 min-w-0">
                                  <h4 
                                    className="font-semibold text-xs truncate" 
                                    title={getCardHeaderText(order)}
                                  >
                                    {getCardHeaderText(order)}
                                  </h4>
                                  
                                  {/* Badge'y z numerami */}
                                  <div className="flex items-center gap-1 flex-wrap mt-0.5">
                                    <span className="text-[8px] font-mono bg-blue-100 text-blue-700 px-1 rounded" title="Numer zlecenia">
                                      ğŸ”¢ {order.orderNumber || order.visitId || `ORD-${order.id}`}
                                    </span>
                                    <span className="text-[8px] font-mono bg-purple-100 text-purple-700 px-1 rounded" title="ID klienta">
                                      ğŸ‘¤ {order.clientId || order.customerId || 'BRAK'}
                                    </span>
                                    {order.visits && order.visits.length > 0 && (
                                      <span className="text-[8px] font-mono bg-green-100 text-green-700 px-1 rounded" title={`Wizyty: ${order.visits.map(v => v.visitId || v.id).join(', ')}`}>
                                        ğŸ“… {order.visits.length}
                                      </span>
                                    )}
                                  </div>
                                  
                                  {/* Przyciski akcji */}
                                  {heightPercent > 5 && (
                                    <div className="flex items-center gap-1 mt-1">
                                      {/* Dropdown zmiany technika */}
                                      {availableServicemen.length > 1 && (
                                        <select
                                          onClick={(e) => e.stopPropagation()}
                                          onChange={async (e) => {
                                            e.stopPropagation();
                                            const newTechnicianId = e.target.value;
                                            if (newTechnicianId && newTechnicianId !== currentServiceman) {
                                              const scheduledDate = order.scheduledDate || day;
                                              try {
                                                const response = await fetch(`/api/orders/${order.id}`, {
                                                  method: 'PATCH',
                                                  headers: { 'Content-Type': 'application/json' },
                                                  body: JSON.stringify({ 
                                                    assignedTo: newTechnicianId,
                                                    scheduledDate: scheduledDate
                                                  })
                                                });
                                                if (response.ok) {
                                                  showNotification(`âœ… Przeniesiono do innego technika`, 'success');
                                                  setTimeout(() => loadIntelligentPlan(), 500);
                                                }
                                              } catch (error) {
                                                console.error('BÅ‚Ä…d:', error);
                                                showNotification(`âŒ BÅ‚Ä…d zmiany technika`, 'error');
                                              }
                                            }
                                          }}
                                          className="text-[8px] px-1 py-0.5 rounded bg-blue-100 text-blue-700 hover:bg-blue-200 cursor-pointer border-0"
                                          value={currentServiceman}
                                        >
                                          <option value="">ğŸ‘¤ ZmieÅ„...</option>
                                          {availableServicemen.map(tech => (
                                            <option key={tech.id} value={tech.id}>{tech.name}</option>
                                          ))}
                                        </select>
                                      )}
                                      
                                      {/* Przycisk przeniesienia do nieprzypisanych */}
                                      <button
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          moveOrderToUnscheduled(order, day);
                                        }}
                                        className="text-[8px] px-1 py-0.5 rounded bg-gray-100 text-gray-700 hover:bg-red-100 hover:text-red-700"
                                        title="PrzenieÅ› do nieprzypisanych"
                                      >
                                        â†©ï¸
                                      </button>
                                    </div>
                                  )}
                                  
                                  <p 
                                    className="text-[10px] text-gray-600 truncate mt-0.5"
                                    title={order.deviceType}
                                  >
                                    {order.deviceType}
                                  </p>
                                </div>
                                <span className="text-sm font-bold ml-1">
                                  {order.priority === 'urgent' ? 'ğŸ”¥' :
                                   order.priority === 'high' ? 'âš¡' :
                                   order.priority === 'medium' ? 'ğŸ“Œ' : 'âœ…'}
                                </span>
                              </div>
                              
                              <div className="text-[10px] text-gray-700 font-bold bg-white/50 rounded px-1 py-0.5 inline-block">
                                ğŸ•’ {startTime} - {endTime}
                              </div>
                              
                              <div className="text-[9px] text-gray-600 mt-1">
                                â±ï¸ {duration} min
                              </div>
                              
                              {order.address && heightPercent > 4 && (
                                <div className="text-[8px] text-gray-500 mt-1 truncate" title={order.address}>
                                  ğŸ“ {order.address}
                                </div>
                              )}
                              
                              {/* WskazÃ³wka przy hover */}
                              <div className="absolute bottom-1 left-1/2 transform -translate-x-1/2 text-[8px] text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap bg-white/80 px-1 rounded">
                                PrzeciÄ…gnij â†•ï¸ lub â†”ï¸
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  );
                })()}
                
                {/* Statystyki dnia (pod timeline) */}
                <div className="p-3 bg-gray-50 border-t border-gray-200">
                  {dayOrders.length === 0 ? (
                    <div className="text-center text-xs text-gray-500">
                      {isDragging 
                        ? `ğŸ“¦ PrzeciÄ…gnij "${draggedOrder?.order?.clientName}" na timeline` 
                        : 'Brak zleceÅ„ - przeciÄ…gnij zlecenie z puli nieprzypisanych'
                      }
                    </div>
                  ) : (
                    <div className="text-xs text-gray-600 space-y-1">
                      <div>ğŸ“¦ Zlecenia: <strong>{dayOrders.length}</strong></div>
                      <div>â±ï¸ ÅÄ…czny czas: <strong>{dayOrders.reduce((sum, o) => sum + (o.estimatedDuration || 60), 0)} min</strong></div>
                      <div>ğŸ’° PrzychÃ³d: <strong>{dayOrders.reduce((sum, o) => sum + (o.serviceCost || 150), 0)} zÅ‚</strong></div>
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
};

export default IntelligentWeekPlanner;
