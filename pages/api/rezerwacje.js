
import { createClient } from '@supabase/supabase-js';
import { readReservations, addReservation, updateReservation } from '../../utils/dataStorage';
import {
  addClient,
  addOrder,
  convertReservationToClientOrder,
  readClients,
  readOrders,
  updateClient,
  updateOrder,
  deleteClient,
  deleteOrder
} from '../../utils/clientOrderStorage';
import { createNotification, NotificationTemplates } from '../../utils/notificationHelper';

// Tymczasowe przechowywanie danych w pamiƒôci do test√≥w (fallback)
let tempStorage = [];

// Spr√≥buj skonfigurowaƒá Supabase
let supabase = null;
try {
  if (process.env.SUPABASE_URL && process.env.SUPABASE_ANON_KEY &&
    !process.env.SUPABASE_URL.includes('twoj-projekt') &&
    !process.env.SUPABASE_ANON_KEY.includes('wtetrtvtblzkguoxfumx')) {
    supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );
  }
} catch (error) {
  console.log('Supabase not configured, using in-memory storage');
}

export default async function handler(req, res) {
  if (req.method === 'POST') {
    console.log('üìû API POST /api/rezerwacje - otrzymane dane:', req.body);

    const { name, phone, email, city, street, fullAddress, address, category, device, problem, date, availability } = req.body;

    // Podstawowa walidacja - tylko name i phone sƒÖ wymagane
    if (!name || !phone) {
      console.log('‚ùå Brak wymaganych danych (name, phone)');
      return res.status(400).json({ message: 'Brak wymaganych danych: nazwa i telefon' });
    }

    // Sprawd≈∫ czy mamy adres w jakiejkolwiek formie
    const finalAddress = address || fullAddress || (street && city ? `${street}, ${city}` : null);
    if (!finalAddress) {
      console.log('‚ùå Brak adresu');
      return res.status(400).json({ message: 'Brak adresu - podaj pe≈Çny adres lub miasto i ulicƒô' });
    }

    console.log('‚úÖ Walidacja przesz≈Ça, tworzenie rekordu...');

    const newReservation = {
      id: Date.now(),
      name,
      phone,
      email,
      city: city || 'Nie podano',
      street: street || 'Nie podano',
      address: finalAddress,
      category,
      device,
      problem: problem || 'Brak opisu',
      availability: availability || 'Nie okre≈õlono', // New availability field
      date: date || new Date().toISOString(), // Keep date for backward compatibility
      created_at: new Date().toISOString(),
      status: 'pending', // ‚úÖ Dodaj domy≈õlny status
      // üåç WSP√ì≈ÅRZƒòDNE GPS z geocodingu
      clientLocation: req.body.clientLocation || null,
      postalCode: req.body.postalCode || '',
      // ‚úÖ Dodaj userId i isAuthenticated
      userId: req.body.userId || null,
      isAuthenticated: req.body.isAuthenticated || false,
      // Przeka≈º wszystkie dodatkowe pola z formularza
      ...req.body
    };

    console.log('üîÑ Converting reservation to client+order format...');

    // Deklaruj zmienne na wy≈ºszym poziomie (dostƒôpne w ca≈Çym handlerze)
    let newClient = null;
    let newOrder = null;
    let clientData = null;
    let orderData = null;

    try {
      // ‚úÖ NOWE: Sprawd≈∫ czy klient ju≈º istnieje (zapobieganie duplikatom)
      const { isLoggedIn, userId, clientPhone } = req.body;
      const clients = await readClients();
      let existingClient = null;

      console.log('üîç Sprawdzanie istniejƒÖcego klienta...', { isLoggedIn, userId, clientPhone });

      // Priorytet 1: Zalogowany u≈ºytkownik - szukaj po userId
      if (isLoggedIn && userId) {
        existingClient = clients.find(c => c.userId === userId);
        if (existingClient) {
          console.log(`‚úÖ Znaleziono klienta po userId: ${existingClient.id} - ${existingClient.name}`);
        }
      }

      // Priorytet 2: Nie znaleziono po userId - szukaj po numerze telefonu
      if (!existingClient && clientPhone) {
        const normalizedPhone = clientPhone.replace(/\s+/g, '').replace(/\+48/, '');
        existingClient = clients.find(c => {
          const clientMainPhone = (c.phone || '').replace(/\s+/g, '').replace(/\+48/, '');
          const hasMatchingPhone = c.phones?.some(p => {
            const phoneNum = (p.number || '').replace(/\s+/g, '').replace(/\+48/, '');
            return phoneNum === normalizedPhone;
          });
          return clientMainPhone === normalizedPhone || hasMatchingPhone;
        });
        if (existingClient) {
          console.log(`‚úÖ Znaleziono klienta po numerze telefonu: ${existingClient.id} - ${existingClient.name}`);
        }
      }

      // Je≈õli klient istnieje - u≈ºyj jego danych
      if (existingClient) {
        newClient = existingClient;
        console.log(`‚ôªÔ∏è U≈ºywam istniejƒÖcego klienta - zapobieganie duplikatom`);
      } else {
        // Klient nie istnieje - utw√≥rz nowego
        console.log('‚ûï Klient nie istnieje - tworzenie nowego...');

        // Konwertuj na format klient + zam√≥wienie
        const converted = await convertReservationToClientOrder({
          ...newReservation,
          clientName: name,
          clientPhone: phone,
          serviceType: device,
          description: problem,
          scheduledDate: date,
          availability: availability, // Pass availability to conversion
          // ‚úÖ Przeka≈º userId do konwersji
          userId: newReservation.userId,
          isAuthenticated: newReservation.isAuthenticated,
          // Przeka≈º tablice z multi-item danych
          phones: req.body.phones || [],
          addresses: req.body.addresses || [],
          devices: req.body.devices || []
        });

        clientData = converted.client;
        orderData = converted.order;

        console.log('üì¶ Converted client data:', clientData);
        console.log('üì¶ Converted order data:', orderData);

        // Dodaj klienta
        newClient = await addClient(clientData);
      }

      // Je≈õli nie mamy orderData (bo u≈ºyli≈õmy istniejƒÖcego klienta), konwertuj teraz
      if (!orderData) {
        const converted = await convertReservationToClientOrder({
          ...newReservation,
          clientName: name,
          clientPhone: phone,
          serviceType: device,
          description: problem,
          scheduledDate: date,
          availability: availability,
          userId: newReservation.userId,
          isAuthenticated: newReservation.isAuthenticated,
          phones: req.body.phones || [],
          addresses: req.body.addresses || [],
          devices: req.body.devices || []
        });
        orderData = converted.order;
      }
      if (newClient) {
        console.log(`‚úÖ Client created: ${newClient.id} - ${newClient.name} (source: ${newClient.source})`);
        
        // Utw√≥rz notyfikacjƒô o nowym kliencie
        await createNotification(NotificationTemplates.newClient(newClient.name));

        // Przygotuj dane zam√≥wienia z ID klienta
        const orderWithClientId = {
          ...orderData,
          clientId: newClient.id
        };
        
        console.log('üì¶ Adding order with data:', {
          clientId: orderWithClientId.clientId,
          deviceType: orderWithClientId.deviceType,
          brand: orderWithClientId.brand,
          model: orderWithClientId.model,
          status: orderWithClientId.status,
          devicesCount: orderWithClientId.devices?.length || 0
        });

        // Dodaj zam√≥wienie z ID klienta
        newOrder = await addOrder(orderWithClientId);

        if (newOrder) {
          console.log(`‚úÖ Order created: ${newOrder.orderNumber} (ID: ${newOrder.id}) for client ${newClient.id}`);
          
          // Utw√≥rz notyfikacjƒô o nowym zam√≥wieniu
          await createNotification(NotificationTemplates.newOrder(
            newOrder.orderNumber, 
            newOrder.deviceType || 'AGD'
          ));
        } else {
          console.error('‚ùå Order creation returned null/undefined - check addOrder function logs above');
          console.error('‚ùå Order data that failed:', JSON.stringify(orderWithClientId, null, 2));
        }
      } else {
        console.error('‚ùå Client creation returned null/undefined');
      }
    } catch (clientOrderError) {
      console.error('‚ùå Error creating client/order:', clientOrderError);
      // Kontynuuj - newClient i newOrder pozostanƒÖ null
    }

    // Utw√≥rz notyfikacjƒô o nowej rezerwacji
    await createNotification(NotificationTemplates.newReservation(
      name,
      category || 'AGD'
    ));

    if (supabase) {
      // U≈ºyj Supabase je≈õli skonfigurowane
      const { data: insertData, error } = await supabase.from('rezerwacje').insert([newReservation]);
      if (error) {
        console.error('Supabase error:', error);
        // Fallback do pliku JSON
        const savedReservation = addReservation(newReservation);
        if (!savedReservation) {
          // Ostateczny fallback do pamiƒôci
          tempStorage.push(newReservation);
        }
      }
    } else {
      // U≈ºyj trwa≈Çego przechowywania w pliku JSON
      const savedReservation = addReservation(newReservation);
      if (savedReservation) {
        console.log('‚úÖ Saved to file:', savedReservation);
      } else {
        // Fallback do pamiƒôci
        tempStorage.push(newReservation);
        console.log('‚ö†Ô∏è Fallback to memory:', newReservation);
      }
    }

    // Wy≈õlij email je≈õli skonfigurowane
    if (process.env.RESEND_API_KEY && !process.env.RESEND_API_KEY.includes('twoj_resend_api_key')) {
      try {
        console.log('üìß Sending email to:', email);

        // Przygotuj dane dla emaila
        const emailDevices = orderData?.devices || [];
        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';

        // Funkcja do mapowania kategorii na nazwƒô ikony SVG
        const getDeviceIconName = (deviceName) => {
          const name = (deviceName || '').toLowerCase();
          if (name.includes('pral')) return 'pralka';
          if (name.includes('lod√≥w') || name.includes('zamra≈º')) return 'lodowka';
          if (name.includes('zmywar')) return 'zmywarka';
          if (name.includes('piekar')) return 'piekarnik';
          if (name.includes('kuchenk')) return 'kuchenka';
          if (name.includes('mikrof')) return 'mikrofalowka';
          if (name.includes('suszar')) return 'suszarka';
          if (name.includes('okap')) return 'okap';
          return 'inne';
        };

        // Generuj listƒô urzƒÖdze≈Ñ dla emaila
        const devicesHtml = emailDevices.length > 0 ? `
          <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h3 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">üì¶ Zg≈Çoszone urzƒÖdzenia:</h3>
            ${emailDevices.map(device => {
              const deviceName = device.name || orderData.deviceType || category || 'UrzƒÖdzenie AGD';
              const deviceIconName = getDeviceIconName(deviceName);
              const deviceDescription = device.description || problem || 'Brak opisu';
              
              return `
                <div style="margin: 10px 0; padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #3b82f6;">
                  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <img src="${baseUrl}/icons/agd/${deviceIconName}.svg" alt="${deviceName}" style="width: 32px; height: 32px;" />
                    <strong style="color: #1e40af; font-size: 16px;">${deviceName}</strong>
                  </div>
                  <div style="color: #666; font-size: 14px; padding-left: 42px;">
                    ${deviceDescription}
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        ` : '';

        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
          </head>
          <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f5f5f5;">
            <div style="max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              
              <!-- Header -->
              <div style="text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 3px solid #3b82f6;">
                <h1 style="color: #1e40af; margin: 0; font-size: 28px;">‚úÖ Potwierdzenie rezerwacji</h1>
                <p style="color: #666; margin: 10px 0 0 0; font-size: 14px;">Twoje zg≈Çoszenie zosta≈Ço pomy≈õlnie przyjƒôte</p>
              </div>

              <!-- Main Content -->
              <div style="margin-bottom: 25px;">
                <p style="color: #333; font-size: 16px; line-height: 1.6;">
                  Witaj <strong>${name}</strong>,<br/><br/>
                  Dziƒôkujemy za z≈Ço≈ºenie zg≈Çoszenia serwisowego. Twoje zg≈Çoszenie zosta≈Ço zarejestrowane i zostanie obs≈Çu≈ºone tak szybko jak to mo≈ºliwe.
                </p>
              </div>

              ${devicesHtml}

              <!-- Details Section -->
              <div style="margin: 20px 0; padding: 15px; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                <h3 style="margin: 0 0 12px 0; color: #0369a1; font-size: 16px;">üìã Szczeg√≥≈Çy zg≈Çoszenia:</h3>
                <table style="width: 100%; border-collapse: collapse;">
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìç Adres:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${finalAddress}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìû Telefon:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${phone}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìß Email:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${email}</td>
                  </tr>
                  ${availability ? `
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üïí Dostƒôpno≈õƒá:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${availability}</td>
                  </tr>
                  ` : ''}
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìÖ Data zg≈Çoszenia:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${new Date(date || Date.now()).toLocaleString('pl-PL')}</td>
                  </tr>
                </table>
              </div>

              <!-- Installation and Built-in Info -->
              ${orderData?.hasBuiltIn ? `
              <div style="margin: 20px 0; padding: 15px; background: #fffbeb; border-radius: 8px; border-left: 4px solid #f59e0b;">
                <h3 style="margin: 0 0 12px 0; color: #92400e; font-size: 16px;">üîß Informacje o zabudowie:</h3>
                <div style="color: #666; font-size: 14px; line-height: 1.8;">
                  <p style="margin: 0 0 8px 0;"><strong style="color: #92400e;">‚ö†Ô∏è UrzƒÖdzenie w zabudowie</strong></p>
                  <p style="margin: 0 0 4px 0; padding-left: 20px;">‚Ä¢ UrzƒÖdzenie jest wbudowane w meble kuchenne</p>
                  <p style="margin: 0 0 4px 0; padding-left: 20px;">‚Ä¢ Wymaga demonta≈ºu i monta≈ºu</p>
                  ${orderData.hasTrudnaZabudowa ? '<p style="margin: 0; padding-left: 20px; color: #dc2626;"><strong>‚Ä¢ Trudna zabudowa - ograniczony dostƒôp</strong></p>' : ''}
                </div>
              </div>
              ` : ''}

              <!-- Next Steps -->
              <div style="margin: 25px 0; padding: 15px; background: #f0fdf4; border-radius: 8px; border-left: 4px solid #22c55e;">
                <h3 style="margin: 0 0 10px 0; color: #15803d; font-size: 16px;">üöÄ Co dalej?</h3>
                <ul style="margin: 0; padding-left: 20px; color: #666; font-size: 14px; line-height: 1.8;">
                  <li>Nasz zesp√≥≈Ç skontaktuje siƒô z TobƒÖ w ciƒÖgu <strong>24 godzin</strong></li>
                  <li>Ustalimy dogodny termin wizyty serwisanta</li>
                  <li>Otrzymasz SMS z przypomnieniem dzie≈Ñ przed wizytƒÖ</li>
                </ul>
              </div>

              <!-- Footer -->
              <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e5e7eb; text-align: center;">
                <p style="color: #999; font-size: 13px; margin: 0;">
                  Je≈õli masz pytania, skontaktuj siƒô z nami odpowiadajƒÖc na tego maila<br/>
                  lub dzwoniƒÖc pod numer podany na naszej stronie.
                </p>
                <p style="color: #bbb; font-size: 12px; margin: 15px 0 0 0;">
                  ¬© ${new Date().getFullYear()} Serwis AGD - Profesjonalne naprawy sprzƒôtu AGD
                </p>
              </div>

            </div>
          </body>
          </html>
        `;

        const emailResponse = await fetch('https://api.resend.com/emails', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${process.env.RESEND_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            from: process.env.RESEND_EMAIL_FROM,
            to: email,
            subject: '‚úÖ Potwierdzenie rezerwacji serwisu AGD',
            html: emailHtml
          })
        });

        if (!emailResponse.ok) {
          const errorData = await emailResponse.json();
          throw new Error(`Resend API error: ${errorData.message || emailResponse.statusText}`);
        }

        const emailResult = await emailResponse.json();
        console.log('‚úÖ Email sent successfully to:', email);
        console.log('üìß Resend response:', emailResult);
        
        return res.status(200).json({ 
          message: 'Rezerwacja przyjƒôta', 
          data: newReservation,
          order: newOrder || { orderNumber: 'Bƒôdzie przydzielony wkr√≥tce', id: null },
          client: newClient,
          emailSent: true,
          emailError: null
        });
      } catch (emailError) {
        console.error('‚ùå Email error:', emailError);
        const errorMessage = emailError.message || 'Nieznany b≈ÇƒÖd podczas wysy≈Çania emaila';
        console.error('üìß Email error details:', errorMessage);
        
        return res.status(200).json({ 
          message: 'Rezerwacja przyjƒôta', 
          data: newReservation,
          order: newOrder || { orderNumber: 'Bƒôdzie przydzielony wkr√≥tce', id: null },
          client: newClient,
          emailSent: false,
          emailError: errorMessage
        });
      }
    } else {
      // Email nie skonfigurowany lub wy≈ÇƒÖczony
      console.log('‚ö†Ô∏è Email service not configured');
      return res.status(200).json({ 
        message: 'Rezerwacja przyjƒôta', 
        data: newReservation,
        order: newOrder || { orderNumber: 'Bƒôdzie przydzielony wkr√≥tce', id: null },
        client: newClient,
        emailSent: false,
        emailError: 'Email nie zosta≈Ç wys≈Çany - system emailowy nie jest skonfigurowany'
      });
    }

  }

  if (req.method === 'GET') {
    console.log('üìû API GET request - pobieranie listy rezerwacji');
    const { id } = req.query;

    if (supabase) {
      try {
        console.log('üîó Pr√≥ba pobrania danych z Supabase...');
        
        // Je≈õli podano ID, pobierz pojedynczƒÖ rezerwacjƒô
        if (id) {
          const { data, error } = await supabase.from('rezerwacje').select('*').eq('id', id).single();
          if (!error && data) {
            console.log('‚úÖ Single reservation retrieved:', data);
            return res.status(200).json(data);
          } else if (error) {
            console.log('‚ùå Supabase error:', error);
          }
        } else {
          // Pobierz wszystkie rezerwacje
          const { data, error } = await supabase.from('rezerwacje').select('*').order('date', { ascending: true });
          if (!error) {
            console.log('‚úÖ Supabase data retrieved:', data);
            return res.status(200).json({ rezerwacje: data });
          } else {
            console.log('‚ùå Supabase error:', error);
          }
        }
      } catch (error) {
        console.error('‚ùå Supabase fetch error:', error);
      }
    }

    // Pr√≥buj odczytaƒá z pliku JSON (legacy format)
    try {
      const fileReservations = readReservations();
      console.log('üìÅ Legacy reservations from file:', fileReservations.length);
    } catch (error) {
      console.error('‚ùå File read error:', error);
    }

    // G≈Ç√≥wne ≈∫r√≥d≈Ço danych: rezervacje.json
    try {
      const reservations = readReservations();
      console.log(`üìä Reservations from file: ${reservations.length}`);

      // Je≈õli szukamy konkretnej rezerwacji po ID
      if (id) {
        // Por√≥wnuj zar√≥wno jako string jak i jako number
        const singleReservation = reservations.find(r => 
          r.id === id || r.id === Number(id) || String(r.id) === String(id)
        );
        if (singleReservation) {
          console.log('‚úÖ Single reservation found:', id);
          // Przekszta≈Çƒá na format zgodny z formularzem
          return res.status(200).json({
            ...singleReservation,
            name: singleReservation.name || singleReservation.clientName,
            phone: singleReservation.phone || singleReservation.clientPhone,
            email: singleReservation.email || singleReservation.clientEmail,
            address: singleReservation.address || singleReservation.clientAddress,
            city: singleReservation.city || '',
            postalCode: singleReservation.postalCode || '',
            category: singleReservation.category || singleReservation.deviceType || singleReservation.device,
            description: singleReservation.description || singleReservation.problem || singleReservation.issueDescription,
            date: singleReservation.date || singleReservation.scheduledDate || singleReservation.preferredDate,
            time: singleReservation.time || singleReservation.scheduledTime || singleReservation.preferredTime,
            status: singleReservation.status || 'pending',
            notes: singleReservation.notes || ''
          });
        }
      }

      // Zwr√≥ƒá wszystkie rezerwacje - jako tablicƒô (nie obiekt)
      console.log('‚úÖ Returning reservations:', reservations.length, 'items');
      return res.status(200).json(reservations);
    } catch (error) {
      console.error('‚ùå Error reading reservations:', error);
    }

    // Fallback: klienci + zam√≥wienia
    try {
      const clients = await readClients();
      const orders = await readOrders();

      console.log(`üìä Data summary: ${clients.length} clients, ${orders.length} orders`);

      // Konwertuj na format zgodny z mapƒÖ i stronƒÖ /admin/rezerwacje
      const combinedReservations = clients.map(client => {
        const clientOrders = orders.filter(order => order.clientId === client.id);
        const mainOrder = clientOrders[0]; // U≈ºyj pierwszego zam√≥wienia

        return {
          id: client.id,
          // Dla kompatybilno≈õci z r√≥≈ºnymi widokami - oba formaty
          name: client.name,
          clientName: client.name,
          phone: client.phone,
          clientPhone: client.phone,
          email: client.email,
          address: client.address,
          city: client.city,
          street: client.street,
          postalCode: client.postalCode || '',
          serviceType: mainOrder?.category || mainOrder?.serviceType || 'Nie okre≈õlono',
          device: mainOrder?.devices?.[0]?.name || 'Nie okre≈õlono',
          problem: mainOrder?.description || 'Brak opisu',
          description: mainOrder?.description || 'Brak opisu',
          scheduledDate: mainOrder?.scheduledDate || mainOrder?.dates?.[0],
          scheduledTime: mainOrder?.scheduledTime,
          time: mainOrder?.scheduledTime || mainOrder?.availability, // Dodaj pole 'time' dla tabeli
          status: mainOrder?.status || 'pending',
          priority: mainOrder?.priority || 'normal',
          created_at: client.dateAdded,
          createdAt: client.createdAt || client.dateAdded,
          date: mainOrder?.scheduledDate || mainOrder?.dates?.[0] || client.dateAdded,
          notes: mainOrder?.notes || '',
          // Dodatkowe pola dla kompatybilno≈õci z mapƒÖ
          category: mainOrder?.category || 'serwis',
          ordersCount: clientOrders.length,
          // Dane zam√≥wienia dla edycji
          orderId: mainOrder?.id,
          orderNumber: mainOrder?.orderNumber
        };
      });

      // Je≈õli szukamy konkretnej rezerwacji po ID
      if (id) {
        // Por√≥wnuj zar√≥wno jako string jak i jako number
        const singleReservation = combinedReservations.find(r => 
          r.id === id || r.id === Number(id) || String(r.id) === String(id)
        );
        if (singleReservation) {
          console.log('‚úÖ Single reservation found:', id);
          return res.status(200).json(singleReservation);
        } else {
          console.log('‚ùå Reservation not found:', id);
          return res.status(404).json({ message: 'Rezerwacja nie znaleziona' });
        }
      }

      if (combinedReservations.length > 0) {
        console.log('‚úÖ Returning combined client+order data:', combinedReservations.length, 'items');
        return res.status(200).json({ rezerwacje: combinedReservations });
      }
    } catch (error) {
      console.error('‚ùå Error reading clients/orders:', error);
    }

    // Fallback do pamiƒôci
    console.log('üì§ Fallback to memory storage:', tempStorage.length, 'items');
    console.log(`üìä Zwracam ${tempStorage.length} rezerwacji z pamiƒôci`);
    return res.status(200).json({ rezerwacje: tempStorage });
  }

  if (req.method === 'PUT') {
    console.log('üìû API PUT /api/rezerwacje - aktualizacja rezerwacji');
    const { id, orderId, orderNumber, ...updateData } = req.body;

    if (!id) {
      return res.status(400).json({ message: 'Brak ID rezerwacji' });
    }

    console.log(`üîç Updating reservation/client: ${id}`);
    console.log('üìù Update data:', updateData);

    // Najpierw spr√≥buj zaktualizowaƒá jako rezerwacjƒô (numeric ID)
    try {
      const reservations = readReservations();
      const reservationIndex = reservations.findIndex(r => 
        r.id === id || r.id === Number(id) || String(r.id) === String(id)
      );

      if (reservationIndex !== -1) {
        // Znaleziono rezerwacjƒô - aktualizuj jƒÖ
        console.log('‚úÖ Found reservation at index:', reservationIndex);
        const reservation = reservations[reservationIndex];
        
        // Sprawd≈∫ czy zmiana statusu na "contacted" - konwertuj na zlecenie
        if (updateData.status === 'contacted' && reservation.status !== 'contacted') {
          console.log('üîÑ Status changed to "contacted" - converting to order');
          
          try {
            // Przygotuj dane rezerwacji do konwersji
            const reservationToConvert = {
              ...reservation,
              ...updateData
            };
            
            // Konwertuj rezerwacjƒô na klienta i zam√≥wienie
            const converted = await convertReservationToClientOrder(reservationToConvert);
            let clientData = converted.client;
            let orderData = converted.order;
            
            // Sprawd≈∫ czy klient ju≈º istnieje (po telefonie lub emailu)
            const clients = await readClients();
            let existingClient = null;
            
            if (clientData.phone) {
              existingClient = clients.find(c => c.phone === clientData.phone);
            }
            
            if (!existingClient && clientData.email) {
              existingClient = clients.find(c => c.email === clientData.email);
            }
            
            let clientId;
            let client;
            
            if (existingClient) {
              console.log('üìã Client already exists, using existing ID:', existingClient.id);
              clientId = existingClient.id;
              client = existingClient;
              
              // Aktualizuj dane istniejƒÖcego klienta
              const updatedClient = {
                ...existingClient,
                ...clientData,
                id: existingClient.id, // Zachowaj oryginalny ID
                updatedAt: new Date().toISOString()
              };
              await updateClient(updatedClient);
            } else {
              // Dodaj metadane o ≈∫r√≥dle
              clientData.source = 'reservation_conversion';
              clientData.createdBy = 'admin';
              clientData.originalReservationId = reservation.id;
              
              // Utw√≥rz nowego klienta
              const newClient = await addClient(clientData);
              clientId = newClient.id;
              client = newClient;
              console.log('‚úÖ New client created from reservation:', clientId);
            }
            
            // Sprawd≈∫ czy zam√≥wienie dla tej rezerwacji ju≈º istnieje
            const orders = await readOrders();
            const existingOrder = orders.find(o => 
              o.originalReservationId === reservation.id || 
              o.reservationId === reservation.id
            );
            
            if (existingOrder) {
              console.log('üìã Order already exists for this reservation:', existingOrder.orderNumber);
              
              // ‚úÖ FIX: Aktualizuj rezerwacjƒô z danymi istniejƒÖcego zam√≥wienia
              const result = updateReservation(reservation.id, {
                ...updateData,
                orderId: existingOrder.id,
                orderNumber: existingOrder.orderNumber,
                clientId: clientId,
                convertedToOrder: true,
                convertedAt: existingOrder.createdAt || new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                updatedBy: 'admin'
              });
              
              console.log('‚úÖ Reservation linked to existing order');
              return res.status(200).json({ 
                message: 'Rezerwacja po≈ÇƒÖczona z istniejƒÖcym zleceniem', 
                data: result,
                client: client,
                order: existingOrder
              });
            } else {
              // Po≈ÇƒÖcz zam√≥wienie z klientem
              orderData.clientId = clientId;
              orderData.source = 'reservation_conversion';
              orderData.originalReservationId = reservation.id;
              orderData.reservationId = reservation.id;
              orderData.createdBy = 'admin';
              orderData.createdFrom = 'reservation';
              
              // Utw√≥rz zam√≥wienie
              const newOrder = await addOrder(orderData);
              console.log('‚úÖ Order created from reservation:', newOrder.orderNumber);
              
              // ‚úÖ FIX: Aktualizuj rezerwacjƒô ze statusem i numerem zam√≥wienia
              const result = updateReservation(reservation.id, {
                ...updateData,
                orderId: newOrder.id,
                orderNumber: newOrder.orderNumber,
                clientId: clientId,
                convertedToOrder: true,
                convertedAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                updatedBy: 'admin'
              });
              
              console.log('‚úÖ Reservation converted to order successfully');
              console.log('üìã Order ID:', newOrder.id, 'Order Number:', newOrder.orderNumber);
              console.log('üìã Updated reservation:', result);
              
              return res.status(200).json({ 
                message: 'Rezerwacja przekonwertowana na zlecenie', 
                data: result,
                client: client,
                order: newOrder
              });
            }
          } catch (conversionError) {
            console.error('‚ùå Error converting reservation to order:', conversionError);
            // Kontynuuj z normalnƒÖ aktualizacjƒÖ je≈õli konwersja siƒô nie powiod≈Ça
          }
        }
        
        // Standardowa aktualizacja rezerwacji
        const result = updateReservation(reservation.id, {
          ...updateData,
          updatedAt: new Date().toISOString(),
          updatedBy: 'admin'
        });

        if (result) {
          console.log('‚úÖ Reservation updated successfully');
          return res.status(200).json({ 
            message: 'Rezerwacja zaktualizowana', 
            data: result 
          });
        }
      }
    } catch (error) {
      console.error('‚ùå Error updating reservation:', error);
      // Continue to try client/order update
    }

    if (supabase) {
      try {
        const { data, error } = await supabase
          .from('rezerwacje')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();

        if (!error && data) {
          console.log('‚úÖ Rezerwacja zaktualizowana w Supabase:', data);
          return res.status(200).json({ message: 'Rezerwacja zaktualizowana', data });
        } else {
          console.log('‚ùå Supabase update error:', error);
        }
      } catch (error) {
        console.error('‚ùå Supabase update error:', error);
      }
    }

    // G≈Ç√≥wne ≈∫r√≥d≈Ço danych: klienci + zam√≥wienia
    try {
      const clients = await readClients();
      const orders = await readOrders();

      // Znajd≈∫ klienta
      const client = clients.find(c => c.id === id);
      if (!client) {
        console.log('‚ùå Client not found:', id);
        return res.status(404).json({ message: 'Klient nie znaleziony' });
      }

      // Znajd≈∫ zam√≥wienie dla tego klienta
      const clientOrders = orders.filter(o => o.clientId === id);
      const mainOrder = clientOrders[0];

      // Aktualizuj dane klienta
      const updatedClient = {
        ...client,
        name: updateData.name || client.name,
        phone: updateData.phone || client.phone,
        email: updateData.email || client.email,
        address: updateData.address || client.address,
        city: updateData.city || client.city,
        street: updateData.street || client.street,
        postalCode: updateData.postalCode || client.postalCode,
        updatedAt: new Date().toISOString(),
        updatedBy: 'admin'
      };

      await updateClient(updatedClient);
      console.log('‚úÖ Client updated:', id);

      // Je≈õli istnieje zam√≥wienie, aktualizuj je
      if (mainOrder) {
        const updatedOrder = {
          ...mainOrder,
          category: updateData.category || mainOrder.category,
          description: updateData.description || mainOrder.description,
          status: updateData.status || mainOrder.status,
          scheduledDate: updateData.date || mainOrder.scheduledDate,
          scheduledTime: updateData.time || mainOrder.scheduledTime,
          notes: updateData.notes || mainOrder.notes,
          updatedAt: new Date().toISOString(),
          updatedBy: 'admin'
        };

        await updateOrder(updatedOrder);
        console.log('‚úÖ Order updated:', mainOrder.orderNumber);
      }

      return res.status(200).json({ 
        message: 'Rezerwacja zaktualizowana', 
        data: { ...updatedClient, ...updateData } 
      });

    } catch (error) {
      console.error('‚ùå Error updating client/order:', error);
      return res.status(500).json({ message: 'B≈ÇƒÖd aktualizacji danych' });
    }
  }

  if (req.method === 'DELETE') {
    console.log('üìû API DELETE /api/rezerwacje - usuwanie rezerwacji');
    const { id } = req.query;

    if (!id) {
      return res.status(400).json({ message: 'Brak ID rezerwacji' });
    }

    if (supabase) {
      try {
        const { error } = await supabase
          .from('rezerwacje')
          .delete()
          .eq('id', id);

        if (!error) {
          console.log('‚úÖ Rezerwacja usuniƒôta z Supabase');
          return res.status(200).json({ message: 'Rezerwacja usuniƒôta' });
        } else {
          console.log('‚ùå Supabase delete error:', error);
        }
      } catch (error) {
        console.error('‚ùå Supabase delete error:', error);
      }
    }

    // G≈Ç√≥wne ≈∫r√≥d≈Ço danych: klienci + zam√≥wienia
    try {
      const clients = await readClients();
      const orders = await readOrders();

      // Znajd≈∫ klienta
      const client = clients.find(c => c.id === id);
      if (!client) {
        console.log('‚ùå Client not found:', id);
        return res.status(404).json({ message: 'Klient nie znaleziony' });
      }

      // Znajd≈∫ wszystkie zam√≥wienia dla tego klienta
      const clientOrders = orders.filter(o => o.clientId === id);

      // Usu≈Ñ wszystkie zam√≥wienia
      for (const order of clientOrders) {
        await deleteOrder(order.id);
        console.log('‚úÖ Order deleted:', order.orderNumber);
      }

      // Usu≈Ñ klienta
      await deleteClient(id);
      console.log('‚úÖ Client deleted:', id);

      return res.status(200).json({ message: 'Rezerwacja usuniƒôta' });

    } catch (error) {
      console.error('‚ùå Error deleting client/orders:', error);
      return res.status(500).json({ message: 'B≈ÇƒÖd usuwania danych' });
    }
  }

  return res.status(405).json({ message: 'Method Not Allowed' });
}
