
import { createClient } from '@supabase/supabase-js';
import { readReservations, addReservation, updateReservation } from '../../utils/dataStorage';
import {
  addClient,
  addOrder,
  convertReservationToClientOrder,
  readClients,
  readOrders,
  updateClient,
  updateOrder,
  deleteClient,
  deleteOrder
} from '../../utils/clientOrderStorage';
import { createNotification, NotificationTemplates } from '../../utils/notificationHelper';
import { apiLogger, logger } from '../../utils/logger';

// Tymczasowe przechowywanie danych w pamiƒôci do test√≥w (fallback)
let tempStorage = [];

// Spr√≥buj skonfigurowaƒá Supabase
let supabase = null;
try {
  const supabaseUrl = (process.env.SUPABASE_URL_CLEAN || process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL || '').trim();
  const supabaseKey = (process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || process.env.SUPABASE_ANON_KEY || '').trim();
  
  console.log('üîçüîçüîç Checking Supabase config:', {
    hasUrl: !!supabaseUrl,
    hasKey: !!supabaseKey,
    urlPreview: supabaseUrl ? supabaseUrl.substring(0, 50) : 'MISSING',
    keyPreview: supabaseKey ? supabaseKey.substring(0, 20) + '...' : 'MISSING',
    urlCheck: supabaseUrl ? !supabaseUrl.includes('twoj-projekt') : false,
    keyCheck: supabaseKey ? !supabaseKey.includes('wtetrtvtblzkguoxfumx') : false
  });
  
  if (supabaseUrl && supabaseKey &&
    !supabaseUrl.includes('twoj-projekt') &&
    !supabaseKey.includes('wtetrtvtblzkguoxfumx')) {
    supabase = createClient(supabaseUrl, supabaseKey);
    console.log('‚úÖ‚úÖ‚úÖ Supabase client created successfully!');
  } else {
    console.warn('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Supabase not configured - using fallback storage');
    if (!supabaseUrl) console.warn('  - Missing URL');
    if (!supabaseKey) console.warn('  - Missing KEY');
    if (supabaseUrl && supabaseUrl.includes('twoj-projekt')) console.warn('  - URL contains placeholder');
    if (supabaseKey && supabaseKey.includes('wtetrtvtblzkguoxfumx')) console.warn('  - KEY contains placeholder');
  }
} catch (error) {
  console.error('‚ùå Supabase initialization error:', error);
}

export default async function handler(req, res) {
  // üö® DEBUG: Sprawd≈∫ czy Supabase jest zainicjalizowany
  console.log('üî•üî•üî• HANDLER START - supabase is:', supabase ? 'INITIALIZED' : 'NULL');
  
  if (req.method === 'POST') {
    

    const { name, phone, email, city, street, fullAddress, address, category, device, problem, date, availability } = req.body;

    // Podstawowa walidacja - tylko name i phone sƒÖ wymagane
    if (!name || !phone) {
      
      return res.status(400).json({ message: 'Brak wymaganych danych: nazwa i telefon' });
    }

    // Sprawd≈∫ czy mamy adres w jakiejkolwiek formie
    const finalAddress = address || fullAddress || (street && city ? `${street}, ${city}` : null);
    if (!finalAddress) {
      
      return res.status(400).json({ message: 'Brak adresu - podaj pe≈Çny adres lub miasto i ulicƒô' });
    }

    

    let newReservation = {
      id: Date.now(),
      name,
      phone,
      email,
      city: city || 'Nie podano',
      street: street || 'Nie podano',
      address: finalAddress,
      category,
      device,
      problem: problem || 'Brak opisu',
      availability: availability || 'Nie okre≈õlono', // New availability field
      date: date || new Date().toISOString(), // Keep date for backward compatibility
      created_at: new Date().toISOString(),
      status: 'pending', // ‚úÖ Dodaj domy≈õlny status
      // üåç WSP√ì≈ÅRZƒòDNE GPS z geocodingu
      clientLocation: req.body.clientLocation || null,
      postalCode: req.body.postalCode || '',
      // ‚úÖ Dodaj userId i isAuthenticated
      userId: req.body.userId || null,
      isAuthenticated: req.body.isAuthenticated || false,
      // Przeka≈º wszystkie dodatkowe pola z formularza
      ...req.body
    };

    

    // Deklaruj zmienne na wy≈ºszym poziomie (dostƒôpne w ca≈Çym handlerze)
    let newClient = null;
    let newOrder = null;
    let clientData = null;
    let orderData = null;

    try {
      // ‚úÖ NOWE: Sprawd≈∫ czy klient ju≈º istnieje (zapobieganie duplikatom)
      const { isLoggedIn, userId, clientPhone } = req.body;
      const clients = await readClients();
      let existingClient = null;

      

      // Priorytet 1: Zalogowany u≈ºytkownik - szukaj po userId
      if (isLoggedIn && userId) {
        existingClient = clients.find(c => c.userId === userId);
        if (existingClient) {
          
        }
      }

      // Priorytet 2: Nie znaleziono po userId - szukaj po numerze telefonu
      if (!existingClient && clientPhone) {
        const normalizedPhone = clientPhone.replace(/\s+/g, '').replace(/\+48/, '');
        existingClient = clients.find(c => {
          const clientMainPhone = (c.phone || '').replace(/\s+/g, '').replace(/\+48/, '');
          const hasMatchingPhone = c.phones?.some(p => {
            const phoneNum = (p.number || '').replace(/\s+/g, '').replace(/\+48/, '');
            return phoneNum === normalizedPhone;
          });
          return clientMainPhone === normalizedPhone || hasMatchingPhone;
        });
        if (existingClient) {
          
        }
      }

      // Je≈õli klient istnieje - u≈ºyj jego danych
      if (existingClient) {
        newClient = existingClient;
        
      } else {
        // Klient nie istnieje - utw√≥rz nowego
        

        // Konwertuj na format klient + zam√≥wienie
        const converted = await convertReservationToClientOrder({
          ...newReservation,
          clientName: name,
          clientPhone: phone,
          serviceType: device,
          description: problem,
          scheduledDate: date,
          availability: availability, // Pass availability to conversion
          // ‚úÖ Przeka≈º userId do konwersji
          userId: newReservation.userId,
          isAuthenticated: newReservation.isAuthenticated,
          // Przeka≈º tablice z multi-item danych
          phones: req.body.phones || [],
          addresses: req.body.addresses || [],
          devices: req.body.devices || []
        });

        clientData = converted.client;
        orderData = converted.order;

        
        

        // Dodaj klienta
        newClient = await addClient(clientData);
      }

      // Je≈õli nie mamy orderData (bo u≈ºyli≈õmy istniejƒÖcego klienta), konwertuj teraz
      if (!orderData) {
        const converted = await convertReservationToClientOrder({
          ...newReservation,
          clientName: name,
          clientPhone: phone,
          serviceType: device,
          description: problem,
          scheduledDate: date,
          availability: availability,
          userId: newReservation.userId,
          isAuthenticated: newReservation.isAuthenticated,
          phones: req.body.phones || [],
          addresses: req.body.addresses || [],
          devices: req.body.devices || []
        });
        orderData = converted.order;
      }
      if (newClient) {
        
        
        // Utw√≥rz notyfikacjƒô o nowym kliencie
        await createNotification(NotificationTemplates.newClient(newClient.name));

        // ‚úÖ TW√ìRZ ZLECENIE od razu przy POST (user dostaje numer natychmiast)
        // ZABEZPIECZENIE: ≈∫r√≥d≈Ço 'W' (web) + zapisany reservationId zapobiega duplikatom
        try {
          
          
          newOrder = await addOrder(orderData, {
            source: 'W', // Web submission - UNIKALNY ≈∫r√≥d≈Çowy kod
            sourceDetails: `Web reservation ${newReservation.id}`,
            createdBy: 'web-form',
            createdByName: 'Formularz WWW',
            userId: newReservation.userId,
            isUserCreated: !!newReservation.isAuthenticated,
            ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress
          });

          if (newOrder) {
            
            // Zapisz powiƒÖzanie rezerwacja ‚Üí zlecenie
            newReservation.orderId = newOrder.id;
            newReservation.orderNumber = newOrder.orderNumber;
          } else {
            console.error('‚ùå addOrder returned null - zlecenie nie zosta≈Ço utworzone');
          }
        } catch (orderError) {
          console.error('‚ùå B≈ÇƒÖd tworzenia zlecenia:', orderError);
          // Nie przerywaj - rezerwacja jest OK, zlecenie mo≈ºna utworzyƒá p√≥≈∫niej
        }
      } else {
        console.error('‚ùå Client creation returned null/undefined');
      }
    } catch (clientOrderError) {
      console.error('‚ùå Error creating client/order:', clientOrderError);
      // Kontynuuj - newClient i newOrder pozostanƒÖ null
    }

    // Utw√≥rz notyfikacjƒô o nowej rezerwacji
    await createNotification(NotificationTemplates.newReservation(
      name,
      category || 'AGD'
    ));

    if (supabase) {
      // U≈ºyj Supabase je≈õli skonfigurowane
      // Usu≈Ñ id - Supabase wygeneruje auto-increment
      const { id: _removedId, ...reservationForSupabase } = newReservation;
      
      console.log('ÔøΩüöÄüöÄ === SUPABASE INSERT START ===');
      console.log('ÔøΩüì§ Klucze do wys≈Çania:', Object.keys(reservationForSupabase).join(', '));
      console.log('üì§ Przyk≈Çadowe dane:', JSON.stringify({
        name: reservationForSupabase.name,
        phone: reservationForSupabase.phone,
        email: reservationForSupabase.email
      }));
      
      const { data: insertData, error } = await supabase.from('rezerwacje').insert([reservationForSupabase]).select();
      
      console.log('üì• Supabase response - error:', error ? 'YES' : 'NO');
      console.log('üì• Supabase response - data:', insertData ? `Array[${insertData.length}]` : 'NULL');
      
      if (error) {
        console.error('‚ùå‚ùå‚ùå SUPABASE ERROR:', JSON.stringify(error, null, 2));
        // Fallback do pliku JSON
        const savedReservation = addReservation(newReservation);
        if (!savedReservation) {
          // Ostateczny fallback do pamiƒôci
          tempStorage.push(newReservation);
        }
      } else if (insertData && insertData[0]) {
        console.log('‚úÖ‚úÖ‚úÖ Supabase zwr√≥ci≈Ç ID:', insertData[0].id);
        // Zaktualizuj newReservation z danymi z Supabase (zawiera ID!)
        Object.assign(newReservation, insertData[0]);
        console.log('‚úÖ newReservation.id PO UPDATE:', newReservation.id);
      } else {
        console.log('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Supabase nie zwr√≥ci≈Ç danych!');
      }
      console.log('üèÅüèÅüèÅ === SUPABASE INSERT END ===');
    } else {
      // U≈ºyj trwa≈Çego przechowywania w pliku JSON
      const savedReservation = addReservation(newReservation);
      if (savedReservation) {
        
      } else {
        // Fallback do pamiƒôci
        tempStorage.push(newReservation);
        
      }
    }

    // Wy≈õlij email je≈õli skonfigurowane
    if (process.env.RESEND_API_KEY && !process.env.RESEND_API_KEY.includes('twoj_resend_api_key')) {
      try {
        

        // Przygotuj dane dla emaila
        const emailDevices = orderData?.devices || [];
        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';

        // Funkcja do mapowania kategorii na nazwƒô ikony SVG
        const getDeviceIconName = (deviceName) => {
          const name = (deviceName || '').toLowerCase();
          if (name.includes('pral')) return 'pralka';
          if (name.includes('lod√≥w') || name.includes('zamra≈º')) return 'lodowka';
          if (name.includes('zmywar')) return 'zmywarka';
          if (name.includes('piekar')) return 'piekarnik';
          if (name.includes('kuchenk')) return 'kuchenka';
          if (name.includes('mikrof')) return 'mikrofalowka';
          if (name.includes('suszar')) return 'suszarka';
          if (name.includes('okap')) return 'okap';
          return 'inne';
        };

        // Generuj listƒô urzƒÖdze≈Ñ dla emaila
        const devicesHtml = emailDevices.length > 0 ? `
          <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h3 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">üì¶ Zg≈Çoszone urzƒÖdzenia:</h3>
            ${emailDevices.map(device => {
              const deviceName = device.name || orderData.deviceType || category || 'UrzƒÖdzenie AGD';
              const deviceIconName = getDeviceIconName(deviceName);
              const deviceDescription = device.description || problem || 'Brak opisu';
              
              return `
                <div style="margin: 10px 0; padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #3b82f6;">
                  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <img src="${baseUrl}/icons/agd/${deviceIconName}.svg" alt="${deviceName}" style="width: 32px; height: 32px;" />
                    <strong style="color: #1e40af; font-size: 16px;">${deviceName}</strong>
                  </div>
                  <div style="color: #666; font-size: 14px; padding-left: 42px;">
                    ${deviceDescription}
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        ` : '';

        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
          </head>
          <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f5f5f5;">
            <div style="max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              
              <!-- Header -->
              <div style="text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 3px solid #3b82f6;">
                <h1 style="color: #1e40af; margin: 0; font-size: 28px;">‚úÖ Potwierdzenie rezerwacji</h1>
                <p style="color: #666; margin: 10px 0 0 0; font-size: 14px;">Twoje zg≈Çoszenie zosta≈Ço pomy≈õlnie przyjƒôte</p>
              </div>

              <!-- Main Content -->
              <div style="margin-bottom: 25px;">
                <p style="color: #333; font-size: 16px; line-height: 1.6;">
                  Witaj <strong>${name}</strong>,<br/><br/>
                  Dziƒôkujemy za z≈Ço≈ºenie zg≈Çoszenia serwisowego. Twoje zg≈Çoszenie zosta≈Ço zarejestrowane i zostanie obs≈Çu≈ºone tak szybko jak to mo≈ºliwe.
                </p>
              </div>

              ${devicesHtml}

              <!-- Details Section -->
              <div style="margin: 20px 0; padding: 15px; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                <h3 style="margin: 0 0 12px 0; color: #0369a1; font-size: 16px;">üìã Szczeg√≥≈Çy zg≈Çoszenia:</h3>
                <table style="width: 100%; border-collapse: collapse;">
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìç Adres:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${finalAddress}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìû Telefon:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${phone}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìß Email:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${email}</td>
                  </tr>
                  ${availability ? `
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üïí Dostƒôpno≈õƒá:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${availability}</td>
                  </tr>
                  ` : ''}
                  <tr>
                    <td style="padding: 8px 0; color: #666; font-size: 14px;">üìÖ Data zg≈Çoszenia:</td>
                    <td style="padding: 8px 0; color: #333; font-weight: 500; font-size: 14px;">${new Date(date || Date.now()).toLocaleString('pl-PL')}</td>
                  </tr>
                </table>
              </div>

              <!-- Installation and Built-in Info -->
              ${orderData?.hasBuiltIn ? `
              <div style="margin: 20px 0; padding: 15px; background: #fffbeb; border-radius: 8px; border-left: 4px solid #f59e0b;">
                <h3 style="margin: 0 0 12px 0; color: #92400e; font-size: 16px;">üîß Informacje o zabudowie:</h3>
                <div style="color: #666; font-size: 14px; line-height: 1.8;">
                  <p style="margin: 0 0 8px 0;"><strong style="color: #92400e;">‚ö†Ô∏è UrzƒÖdzenie w zabudowie</strong></p>
                  <p style="margin: 0 0 4px 0; padding-left: 20px;">‚Ä¢ UrzƒÖdzenie jest wbudowane w meble kuchenne</p>
                  <p style="margin: 0 0 4px 0; padding-left: 20px;">‚Ä¢ Wymaga demonta≈ºu i monta≈ºu</p>
                  ${orderData.hasTrudnaZabudowa ? '<p style="margin: 0; padding-left: 20px; color: #dc2626;"><strong>‚Ä¢ Trudna zabudowa - ograniczony dostƒôp</strong></p>' : ''}
                </div>
              </div>
              ` : ''}

              <!-- Next Steps -->
              <div style="margin: 25px 0; padding: 15px; background: #f0fdf4; border-radius: 8px; border-left: 4px solid #22c55e;">
                <h3 style="margin: 0 0 10px 0; color: #15803d; font-size: 16px;">üöÄ Co dalej?</h3>
                <ul style="margin: 0; padding-left: 20px; color: #666; font-size: 14px; line-height: 1.8;">
                  <li>Nasz zesp√≥≈Ç skontaktuje siƒô z TobƒÖ w ciƒÖgu <strong>24 godzin</strong></li>
                  <li>Ustalimy dogodny termin wizyty serwisanta</li>
                  <li>Otrzymasz SMS z przypomnieniem dzie≈Ñ przed wizytƒÖ</li>
                </ul>
              </div>

              <!-- Footer -->
              <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e5e7eb; text-align: center;">
                <p style="color: #999; font-size: 13px; margin: 0;">
                  Je≈õli masz pytania, skontaktuj siƒô z nami odpowiadajƒÖc na tego maila<br/>
                  lub dzwoniƒÖc pod numer podany na naszej stronie.
                </p>
                <p style="color: #bbb; font-size: 12px; margin: 15px 0 0 0;">
                  ¬© ${new Date().getFullYear()} Serwis AGD - Profesjonalne naprawy sprzƒôtu AGD
                </p>
              </div>

            </div>
          </body>
          </html>
        `;

        const emailResponse = await fetch('https://api.resend.com/emails', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${process.env.RESEND_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            from: process.env.RESEND_EMAIL_FROM,
            to: email,
            subject: '‚úÖ Potwierdzenie rezerwacji serwisu AGD',
            html: emailHtml
          })
        });

        if (!emailResponse.ok) {
          const errorData = await emailResponse.json();
          throw new Error(`Resend API error: ${errorData.message || emailResponse.statusText}`);
        }

        const emailResult = await emailResponse.json();
        
        
        
        return res.status(200).json({ 
          message: 'Rezerwacja przyjƒôta', 
          data: newReservation,
          order: newOrder || { orderNumber: 'Bƒôdzie przydzielony wkr√≥tce', id: null },
          client: newClient,
          emailSent: true,
          emailError: null
        });
      } catch (emailError) {
        console.error('‚ùå Email error:', emailError);
        const errorMessage = emailError.message || 'Nieznany b≈ÇƒÖd podczas wysy≈Çania emaila';
        console.error('üìß Email error details:', errorMessage);
        
        return res.status(200).json({ 
          message: 'Rezerwacja przyjƒôta', 
          data: newReservation,
          order: newOrder || { orderNumber: 'Bƒôdzie przydzielony wkr√≥tce', id: null },
          client: newClient,
          emailSent: false,
          emailError: errorMessage
        });
      }
    } else {
      // Email nie skonfigurowany lub wy≈ÇƒÖczony
      
      return res.status(200).json({ 
        message: 'Rezerwacja przyjƒôta', 
        data: newReservation,
        order: newOrder || { orderNumber: 'Bƒôdzie przydzielony wkr√≥tce', id: null },
        client: newClient,
        emailSent: false,
        emailError: 'Email nie zosta≈Ç wys≈Çany - system emailowy nie jest skonfigurowany'
      });
    }

  }

  if (req.method === 'GET') {
    
    const { id } = req.query;

    if (supabase) {
      try {
        
        
        // Je≈õli podano ID, pobierz pojedynczƒÖ rezerwacjƒô
        if (id) {
          const { data, error } = await supabase.from('rezerwacje').select('*').eq('id', id).single();
          if (!error && data) {
            
            return res.status(200).json(data);
          } else if (error) {
            
          }
        } else {
          // Pobierz wszystkie rezerwacje
          const { data, error } = await supabase.from('rezerwacje').select('*').order('date', { ascending: true });
          if (!error) {
            console.log(`‚úÖ Loaded ${data.length} reservations from Supabase`);
            return res.status(200).json({ rezerwacje: data });
          } else {
            console.error('‚ùå Supabase GET error:', error);
          }
        }
      } catch (error) {
        console.error('‚ùå Supabase fetch error:', error);
      }
      
      // Je≈õli Supabase jest skonfigurowane ale wystƒÖpi≈Ç b≈ÇƒÖd, zwr√≥ƒá pustƒÖ tablicƒô
      // (nie pr√≥buj filesystem na Vercel)
      if (supabase) {
        console.log('‚ö†Ô∏è Supabase error, returning empty array (no filesystem on Vercel)');
        return res.status(200).json({ rezerwacje: [] });
      }
    }

    // Fallback: tylko lokalnie - pr√≥buj odczytaƒá z pliku JSON
    try {
      const reservations = readReservations();
      

      // Je≈õli szukamy konkretnej rezerwacji po ID
      if (id) {
        // Por√≥wnuj zar√≥wno jako string jak i jako number
        const singleReservation = reservations.find(r => 
          r.id === id || r.id === Number(id) || String(r.id) === String(id)
        );
        if (singleReservation) {
          
          // Przekszta≈Çƒá na format zgodny z formularzem
          return res.status(200).json({
            ...singleReservation,
            name: singleReservation.name || singleReservation.clientName,
            phone: singleReservation.phone || singleReservation.clientPhone,
            email: singleReservation.email || singleReservation.clientEmail,
            address: singleReservation.address || singleReservation.clientAddress,
            city: singleReservation.city || '',
            postalCode: singleReservation.postalCode || '',
            category: singleReservation.category || singleReservation.deviceType || singleReservation.device,
            description: singleReservation.description || singleReservation.problem || singleReservation.issueDescription,
            date: singleReservation.date || singleReservation.scheduledDate || singleReservation.preferredDate,
            time: singleReservation.time || singleReservation.scheduledTime || singleReservation.preferredTime,
            status: singleReservation.status || 'pending',
            notes: singleReservation.notes || ''
          });
        }
      }

      // Zwr√≥ƒá wszystkie rezerwacje - jako tablicƒô (nie obiekt)
      
      return res.status(200).json(reservations);
    } catch (error) {
      console.error('‚ùå Error reading reservations:', error);
    }

    // Fallback: klienci + zam√≥wienia
    try {
      const clients = await readClients();
      const orders = await readOrders();

      

      // Konwertuj na format zgodny z mapƒÖ i stronƒÖ /admin/rezerwacje
      const combinedReservations = clients.map(client => {
        const clientOrders = orders.filter(order => order.clientId === client.id);
        const mainOrder = clientOrders[0]; // U≈ºyj pierwszego zam√≥wienia

        return {
          id: client.id,
          // Dla kompatybilno≈õci z r√≥≈ºnymi widokami - oba formaty
          name: client.name,
          clientName: client.name,
          phone: client.phone,
          clientPhone: client.phone,
          email: client.email,
          address: client.address,
          city: client.city,
          street: client.street,
          postalCode: client.postalCode || '',
          serviceType: mainOrder?.category || mainOrder?.serviceType || 'Nie okre≈õlono',
          device: mainOrder?.devices?.[0]?.name || 'Nie okre≈õlono',
          problem: mainOrder?.description || 'Brak opisu',
          description: mainOrder?.description || 'Brak opisu',
          scheduledDate: mainOrder?.scheduledDate || mainOrder?.dates?.[0],
          scheduledTime: mainOrder?.scheduledTime,
          time: mainOrder?.scheduledTime || mainOrder?.availability, // Dodaj pole 'time' dla tabeli
          status: mainOrder?.status || 'pending',
          priority: mainOrder?.priority || 'normal',
          created_at: client.dateAdded,
          createdAt: client.createdAt || client.dateAdded,
          date: mainOrder?.scheduledDate || mainOrder?.dates?.[0] || client.dateAdded,
          notes: mainOrder?.notes || '',
          // Dodatkowe pola dla kompatybilno≈õci z mapƒÖ
          category: mainOrder?.category || 'serwis',
          ordersCount: clientOrders.length,
          // Dane zam√≥wienia dla edycji
          orderId: mainOrder?.id,
          orderNumber: mainOrder?.orderNumber
        };
      });

      // Je≈õli szukamy konkretnej rezerwacji po ID
      if (id) {
        // Por√≥wnuj zar√≥wno jako string jak i jako number
        const singleReservation = combinedReservations.find(r => 
          r.id === id || r.id === Number(id) || String(r.id) === String(id)
        );
        if (singleReservation) {
          
          return res.status(200).json(singleReservation);
        } else {
          
          return res.status(404).json({ message: 'Rezerwacja nie znaleziona' });
        }
      }

      if (combinedReservations.length > 0) {
        
        return res.status(200).json({ rezerwacje: combinedReservations });
      }
    } catch (error) {
      console.error('‚ùå Error reading clients/orders:', error);
    }

    // Fallback do pamiƒôci
    
    
    return res.status(200).json({ rezerwacje: tempStorage });
  }

  if (req.method === 'PUT') {
    
    const { id, orderId, orderNumber, ...updateData } = req.body;

    if (!id) {
      return res.status(400).json({ message: 'Brak ID rezerwacji' });
    }

    
    

    // Najpierw spr√≥buj zaktualizowaƒá jako rezerwacjƒô (numeric ID)
    try {
      const reservations = readReservations();
      const reservationIndex = reservations.findIndex(r => 
        r.id === id || r.id === Number(id) || String(r.id) === String(id)
      );

      if (reservationIndex !== -1) {
        // Znaleziono rezerwacjƒô - aktualizuj jƒÖ
        
        const reservation = reservations[reservationIndex];
        
        // Sprawd≈∫ czy zmiana statusu na "contacted" - TYLKO AKTUALIZUJ powiƒÖzania
        if (updateData.status === 'contacted' && reservation.status !== 'contacted') {
          
          
          try {
            // Sprawd≈∫ czy zam√≥wienie ju≈º istnieje (utworzone przy POST)
            const orders = await readOrders();
            
            // Szukaj zam√≥wienia po: orderNumber z rezerwacji LUB po ID rezerwacji
            let existingOrder = null;
            
            if (reservation.orderNumber) {
              existingOrder = orders.find(o => o.orderNumber === reservation.orderNumber);
            }
            
            if (!existingOrder) {
              existingOrder = orders.find(o => 
                o.originalReservationId === reservation.id || 
                o.reservationId === reservation.id
              );
            }
            
            if (existingOrder) {
              
              
              // ‚úÖ FIX: Aktualizuj ZAR√ìWNO rezerwacjƒô JAK I zam√≥wienie!
              const result = updateReservation(reservation.id, {
                ...updateData,
                orderId: existingOrder.id,
                orderNumber: existingOrder.orderNumber,
                clientId: reservation.clientId || existingOrder.clientId,
                convertedToOrder: true,
                convertedAt: existingOrder.createdAt || new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                updatedBy: 'admin'
              });
              
              // ‚úÖ NOWE: Synchronizuj status z zam√≥wieniem
              if (updateData.status) {
                
                const updatedOrder = await updateOrder({
                  ...existingOrder,
                  status: updateData.status,
                  updatedAt: new Date().toISOString(),
                  updatedBy: 'admin_reservation'
                });
                
              }
              
              
              return res.status(200).json({ 
                message: 'Status zaktualizowany - rezerwacja i zlecenie zsynchronizowane', 
                data: result,
                order: existingOrder
              });
            }
            
            // FALLBACK: Je≈õli zam√≥wienie nie istnieje (stare rezerwacje), utw√≥rz teraz
            
            
            // Przygotuj dane rezerwacji do konwersji
            const reservationToConvert = {
              ...reservation,
              ...updateData
            };
            
            // Konwertuj rezerwacjƒô na klienta i zam√≥wienie
            const converted = await convertReservationToClientOrder(reservationToConvert);
            let clientData = converted.client;
            let orderData = converted.order;
            
            // Sprawd≈∫ czy klient ju≈º istnieje (po telefonie lub emailu)
            const clients = await readClients();
            let existingClient = null;
            
            if (clientData.phone) {
              existingClient = clients.find(c => c.phone === clientData.phone);
            }
            
            if (!existingClient && clientData.email) {
              existingClient = clients.find(c => c.email === clientData.email);
            }
            
            let clientId;
            let client;
            
            if (existingClient) {
              
              clientId = existingClient.id;
              client = existingClient;
              
              // Aktualizuj dane istniejƒÖcego klienta
              const updatedClient = {
                ...existingClient,
                ...clientData,
                id: existingClient.id, // Zachowaj oryginalny ID
                updatedAt: new Date().toISOString()
              };
              await updateClient(updatedClient);
            } else {
              // Dodaj metadane o ≈∫r√≥dle
              clientData.source = 'reservation_conversion';
              clientData.createdBy = 'admin';
              clientData.originalReservationId = reservation.id;
              
              // Utw√≥rz nowego klienta
              const newClient = await addClient(clientData);
              clientId = newClient.id;
              client = newClient;
              
            }
            
            // Po≈ÇƒÖcz zam√≥wienie z klientem
            orderData.clientId = clientId;
            orderData.source = 'Z'; // Reservation conversion - UNIKALNY kod
            orderData.originalReservationId = reservation.id;
            orderData.reservationId = reservation.id;
            orderData.createdBy = 'admin';
            orderData.createdFrom = 'reservation';
            
            // Utw√≥rz zam√≥wienie (FALLBACK dla starych rezerwacji)
            const newOrder = await addOrder(orderData, {
              source: 'Z',
              sourceDetails: `Legacy reservation ${reservation.id} converted`,
              createdBy: 'admin',
              createdByName: 'Admin Panel'
            });
            
            
            // ‚úÖ FIX: Aktualizuj rezerwacjƒô ze statusem i numerem zam√≥wienia
            const result = updateReservation(reservation.id, {
              ...updateData,
              orderId: newOrder.id,
              orderNumber: newOrder.orderNumber,
              clientId: clientId,
              convertedToOrder: true,
              convertedAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              updatedBy: 'admin'
            });
            
            
            
            
            return res.status(200).json({ 
              message: 'Rezerwacja przekonwertowana na zlecenie', 
              data: result,
              client: client,
              order: newOrder
            });
          } catch (conversionError) {
            console.error('‚ùå Error converting reservation to order:', conversionError);
            // Kontynuuj z normalnƒÖ aktualizacjƒÖ je≈õli konwersja siƒô nie powiod≈Ça
          }
        }
        
        // Standardowa aktualizacja rezerwacji
        const result = updateReservation(reservation.id, {
          ...updateData,
          updatedAt: new Date().toISOString(),
          updatedBy: 'admin'
        });

        if (result) {
          
          return res.status(200).json({ 
            message: 'Rezerwacja zaktualizowana', 
            data: result 
          });
        }
      }
    } catch (error) {
      console.error('‚ùå Error updating reservation:', error);
      // Continue to try client/order update
    }

    if (supabase) {
      try {
        const { data, error } = await supabase
          .from('rezerwacje')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();

        if (!error && data) {
          
          return res.status(200).json({ message: 'Rezerwacja zaktualizowana', data });
        } else {
          
        }
      } catch (error) {
        console.error('‚ùå Supabase update error:', error);
      }
    }

    // G≈Ç√≥wne ≈∫r√≥d≈Ço danych: klienci + zam√≥wienia
    try {
      const clients = await readClients();
      const orders = await readOrders();

      // Znajd≈∫ klienta
      const client = clients.find(c => c.id === id);
      if (!client) {
        
        return res.status(404).json({ message: 'Klient nie znaleziony' });
      }

      // Znajd≈∫ zam√≥wienie dla tego klienta
      const clientOrders = orders.filter(o => o.clientId === id);
      const mainOrder = clientOrders[0];

      // Aktualizuj dane klienta
      const updatedClient = {
        ...client,
        name: updateData.name || client.name,
        phone: updateData.phone || client.phone,
        email: updateData.email || client.email,
        address: updateData.address || client.address,
        city: updateData.city || client.city,
        street: updateData.street || client.street,
        postalCode: updateData.postalCode || client.postalCode,
        updatedAt: new Date().toISOString(),
        updatedBy: 'admin'
      };

      await updateClient(updatedClient);
      

      // Je≈õli istnieje zam√≥wienie, aktualizuj je
      if (mainOrder) {
        const updatedOrder = {
          ...mainOrder,
          category: updateData.category || mainOrder.category,
          description: updateData.description || mainOrder.description,
          status: updateData.status || mainOrder.status,
          scheduledDate: updateData.date || mainOrder.scheduledDate,
          scheduledTime: updateData.time || mainOrder.scheduledTime,
          notes: updateData.notes || mainOrder.notes,
          updatedAt: new Date().toISOString(),
          updatedBy: 'admin'
        };

        await updateOrder(updatedOrder);
        
      }

      return res.status(200).json({ 
        message: 'Rezerwacja zaktualizowana', 
        data: { ...updatedClient, ...updateData } 
      });

    } catch (error) {
      console.error('‚ùå Error updating client/order:', error);
      return res.status(500).json({ message: 'B≈ÇƒÖd aktualizacji danych' });
    }
  }

  if (req.method === 'DELETE') {
    
    const { id } = req.query;

    if (!id) {
      return res.status(400).json({ message: 'Brak ID rezerwacji' });
    }

    if (supabase) {
      try {
        const { error } = await supabase
          .from('rezerwacje')
          .delete()
          .eq('id', id);

        if (!error) {
          
          return res.status(200).json({ message: 'Rezerwacja usuniƒôta' });
        } else {
          
        }
      } catch (error) {
        console.error('‚ùå Supabase delete error:', error);
      }
    }

    // G≈Ç√≥wne ≈∫r√≥d≈Ço danych: klienci + zam√≥wienia
    try {
      const clients = await readClients();
      const orders = await readOrders();

      // Znajd≈∫ klienta
      const client = clients.find(c => c.id === id);
      if (!client) {
        
        return res.status(404).json({ message: 'Klient nie znaleziony' });
      }

      // Znajd≈∫ wszystkie zam√≥wienia dla tego klienta
      const clientOrders = orders.filter(o => o.clientId === id);

      // Usu≈Ñ wszystkie zam√≥wienia
      for (const order of clientOrders) {
        await deleteOrder(order.id);
        
      }

      // Usu≈Ñ klienta
      await deleteClient(id);
      

      return res.status(200).json({ message: 'Rezerwacja usuniƒôta' });

    } catch (error) {
      console.error('‚ùå Error deleting client/orders:', error);
      return res.status(500).json({ message: 'B≈ÇƒÖd usuwania danych' });
    }
  }

  return res.status(405).json({ message: 'Method Not Allowed' });
}


